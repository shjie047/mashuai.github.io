<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Mashuai&#39;s Notes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Mashuai's Notes">
<meta property="og:url" content="https://mashuai.github.io/index.html">
<meta property="og:site_name" content="Mashuai's Notes">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mashuai's Notes">
  
    <link rel="alternative" href="/atom.xml" title="Mashuai&#39;s Notes" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Mashuai&#39;s Notes</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://mashuai.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-okhttp/interceptors" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/19/okhttp/interceptors/" class="article-date">
  <time datetime="2017-03-19T07:47:42.000Z" itemprop="datePublished">2017-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/19/okhttp/interceptors/">OKHttp 拦截器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://github.com/square/okhttp/wiki/Interceptors" target="_blank" rel="external">原文地址</a><br>&emsp;&emsp;拦截器是一种监控，重写，重试请求的强大机制。下面这个例子是一个记录出发出请求和接受响应的简单的拦截器的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class LoggingInterceptor implements Interceptor &#123;</div><div class="line">  @Override public Response intercept(Interceptor.Chain chain) throws IOException &#123;</div><div class="line">    Request request = chain.request();</div><div class="line"></div><div class="line">    long t1 = System.nanoTime();</div><div class="line">    logger.info(String.format(&quot;Sending request %s on %s%n%s&quot;,</div><div class="line">        request.url(), chain.connection(), request.headers()));</div><div class="line"></div><div class="line">    Response response = chain.proceed(request);</div><div class="line"></div><div class="line">    long t2 = System.nanoTime();</div><div class="line">    logger.info(String.format(&quot;Received response for %s in %.1fms%n%s&quot;,</div><div class="line">        response.request().url(), (t2 - t1) / 1e6d, response.headers()));</div><div class="line"></div><div class="line">    return response;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;调用<code>chain.proceed(request)</code>是每个拦截器最重要的实现。这个看起来简单的方法是所有HTTP工作的地方，也是对请求响应的地方。<br>&emsp;&emsp;拦截器可以链式调用。假设你有一个压缩的拦截器和一个校验和的拦截器：你要先确定是先压缩再校验，还是先校验再压缩。OKHTTP使用列表跟踪拦截器，而且拦截器是顺序取消的。<br><img src="https://raw.githubusercontent.com/wiki/square/okhttp/interceptors@2x.png" alt="Interceptors"></p>
<h4 id="应用拦截器"><a href="#应用拦截器" class="headerlink" title="应用拦截器"></a>应用拦截器</h4><p>&emsp;&emsp;拦截器注册为应用拦截器或者网络拦截器。我们将使用上面定义的<code>LoggingInterceptor</code>来展示这两者的不同。<br>&emsp;&emsp;通过调用<code>OkHttpClient.Builder</code>的<code>addInterceptor()</code>来注册一个应用拦截器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">OkHttpClient client = new OkHttpClient.Builder()</div><div class="line">    .addInterceptor(new LoggingInterceptor())</div><div class="line">    .build();</div><div class="line"></div><div class="line">Request request = new Request.Builder()</div><div class="line">    .url(&quot;http://www.publicobject.com/helloworld.txt&quot;)</div><div class="line">    .header(&quot;User-Agent&quot;, &quot;OkHttp Example&quot;)</div><div class="line">    .build();</div><div class="line"></div><div class="line">Response response = client.newCall(request).execute();</div><div class="line">response.body().close();</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;链接<code>http://www.publicobject.com/helloworld.txt</code>重定向到链接<code>http://www.publicobject.com/helloworld.txt</code>,OKHttp回自动重定向。应用拦截器只会被调用一次。<code>chain.proceed()</code>返回的响应是重定向之后的响应。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">INFO: Sending request http://www.publicobject.com/helloworld.txt on null</div><div class="line">User-Agent: OkHttp Example</div><div class="line"></div><div class="line">INFO: Received response for https://publicobject.com/helloworld.txt in 1179.7ms</div><div class="line">Server: nginx/1.4.6 (Ubuntu)</div><div class="line">Content-Type: text/plain</div><div class="line">Content-Length: 1759</div><div class="line">Connection: keep-alive</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;因为<code>response.request().url()</code>和<code>request.url()</code>获取的URL不同，所以可以得出上述结论。两行日志记录了两个不同的URL。</p>
<h4 id="网络拦截器"><a href="#网络拦截器" class="headerlink" title="网络拦截器"></a>网络拦截器</h4><p>&emsp;&emsp;注册网络拦截器和应用拦截器差不多，只是用<code>addNetworkInterceptor()</code>代替了<code>addInterceptor()</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">OkHttpClient client = new OkHttpClient.Builder()</div><div class="line">    .addNetworkInterceptor(new LoggingInterceptor())</div><div class="line">    .build();</div><div class="line"></div><div class="line">Request request = new Request.Builder()</div><div class="line">    .url(&quot;http://www.publicobject.com/helloworld.txt&quot;)</div><div class="line">    .header(&quot;User-Agent&quot;, &quot;OkHttp Example&quot;)</div><div class="line">    .build();</div><div class="line"></div><div class="line">Response response = client.newCall(request).execute();</div><div class="line">response.body().close();</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;当运行这段代码的时候拦截器运行了两次，一次初始的地址<code>http://www.publicobject.com/helloworld.txt</code>，一次是重定向的地址<code>https://publicobject.com/helloworld.txt</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">INFO: Sending request http://www.publicobject.com/helloworld.txt on Connection&#123;www.publicobject.com:80, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=none protocol=http/1.1&#125;</div><div class="line">User-Agent: OkHttp Example</div><div class="line">Host: www.publicobject.com</div><div class="line">Connection: Keep-Alive</div><div class="line">Accept-Encoding: gzip</div><div class="line"></div><div class="line">INFO: Received response for http://www.publicobject.com/helloworld.txt in 115.6ms</div><div class="line">Server: nginx/1.4.6 (Ubuntu)</div><div class="line">Content-Type: text/html</div><div class="line">Content-Length: 193</div><div class="line">Connection: keep-alive</div><div class="line">Location: https://publicobject.com/helloworld.txt</div><div class="line"></div><div class="line">INFO: Sending request https://publicobject.com/helloworld.txt on Connection&#123;publicobject.com:443, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA protocol=http/1.1&#125;</div><div class="line">User-Agent: OkHttp Example</div><div class="line">Host: publicobject.com</div><div class="line">Connection: Keep-Alive</div><div class="line">Accept-Encoding: gzip</div><div class="line"></div><div class="line">INFO: Received response for https://publicobject.com/helloworld.txt in 80.9ms</div><div class="line">Server: nginx/1.4.6 (Ubuntu)</div><div class="line">Content-Type: text/plain</div><div class="line">Content-Length: 1759</div><div class="line">Connection: keep-alive</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;网络请求同时也包含了更多的数据，例如:由OKHttp添加的用来支持响应压缩的<code>Accept-Encoding: gzip</code>header。网络拦截器的<code>chain</code>有一个非空的<code>Connection</code>，用来查询连接服务器的IP地址和TLS配置信息。</p>
<h4 id="如何选择拦截器"><a href="#如何选择拦截器" class="headerlink" title="如何选择拦截器"></a>如何选择拦截器</h4><p>&emsp;&emsp;每种拦截器都有优点。</p>
<h5 id="应用拦截器-1"><a href="#应用拦截器-1" class="headerlink" title="应用拦截器"></a>应用拦截器</h5><ul>
<li>无需关心像重试，重定向等这样的中间过程。</li>
<li>即使是从缓存响应，也会调用一次。</li>
<li>只关心应用最初的目的，并不需要关心OKHttp注入的header，例如<code>If-None-Match</code></li>
<li>允许短路，不执行<code>Chain.proceed()</code></li>
<li>允许重试，执行多次<code>Chain.proceed()</code><h5 id="网络拦截器-1"><a href="#网络拦截器-1" class="headerlink" title="网络拦截器"></a>网络拦截器</h5></li>
<li>可以操作想重试，重定向这样的中间过程。</li>
<li>短路网络连接的从cache返回响应的时候不执行。</li>
<li>可以监控呗发送到网络上的数据</li>
<li>访问包含request的<code>Connection</code><h4 id="重写请求"><a href="#重写请求" class="headerlink" title="重写请求"></a>重写请求</h4>&emsp;&emsp;拦截器可以添加，删除，替换请求头。如果请求有请求体，拦截器也可以转换请求体。例如：如果远程连接的服务器支持压缩，可以使用应用拦截器添加压缩请求体的拦截器。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">/** This interceptor compresses the HTTP request body. Many webservers can&apos;t handle this! */</div><div class="line">final class GzipRequestInterceptor implements Interceptor &#123;</div><div class="line">  @Override public Response intercept(Interceptor.Chain chain) throws IOException &#123;</div><div class="line">    Request originalRequest = chain.request();</div><div class="line">    if (originalRequest.body() == null || originalRequest.header(&quot;Content-Encoding&quot;) != null) &#123;</div><div class="line">      return chain.proceed(originalRequest);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Request compressedRequest = originalRequest.newBuilder()</div><div class="line">        .header(&quot;Content-Encoding&quot;, &quot;gzip&quot;)</div><div class="line">        .method(originalRequest.method(), gzip(originalRequest.body()))</div><div class="line">        .build();</div><div class="line">    return chain.proceed(compressedRequest);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  private RequestBody gzip(final RequestBody body) &#123;</div><div class="line">    return new RequestBody() &#123;</div><div class="line">      @Override public MediaType contentType() &#123;</div><div class="line">        return body.contentType();</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      @Override public long contentLength() &#123;</div><div class="line">        return -1; // We don&apos;t know the compressed length in advance!</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      @Override public void writeTo(BufferedSink sink) throws IOException &#123;</div><div class="line">        BufferedSink gzipSink = Okio.buffer(new GzipSink(sink));</div><div class="line">        body.writeTo(gzipSink);</div><div class="line">        gzipSink.close();</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="重写响应"><a href="#重写响应" class="headerlink" title="重写响应"></a>重写响应</h4><p>&emsp;&emsp;同样拦截器也可以重写响应，转化请求体。通常这样做比重写请求头更危险，因为这样做可能返回的并不是服务器预期值。<br>&emsp;&emsp;如果你处在一个比较棘手的场景，并且准备处理后果，重写响应头就是一个很好的方式处理这类问题。例如：可以修复服务器未配置的<code>Cache-Control</code>来获取更好的缓存响应配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/** Dangerous interceptor that rewrites the server&apos;s cache-control header. */</div><div class="line">private static final Interceptor REWRITE_CACHE_CONTROL_INTERCEPTOR = new Interceptor() &#123;</div><div class="line">  @Override public Response intercept(Interceptor.Chain chain) throws IOException &#123;</div><div class="line">    Response originalResponse = chain.proceed(chain.request());</div><div class="line">    return originalResponse.newBuilder()</div><div class="line">        .header(&quot;Cache-Control&quot;, &quot;max-age=60&quot;)</div><div class="line">        .build();</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;通常为了补充服务器相应的修复，这个方法是最好的。</p>
<h4 id="那些可以使用拦截器"><a href="#那些可以使用拦截器" class="headerlink" title="那些可以使用拦截器"></a>那些可以使用拦截器</h4><p>&emsp;&emsp;使用拦截器要求OKHttp 2.0即以上。不行的是拦截器不可以和<code>OkUrlFactory</code>，或者依赖于他的库同时使用，包括<a href="http://square.github.io/retrofit/" target="_blank" rel="external">Retrofit</a>1.8以下，<a href="http://square.github.io/picasso/" target="_blank" rel="external">Picasso</a>2.4以下。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mashuai.github.io/2017/03/19/okhttp/interceptors/" data-id="cj0ge8y4i001cq0itdxxnvg2e" class="article-share-link">Share</a>
      
        <a href="https://mashuai.github.io/2017/03/19/okhttp/interceptors/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/">HTTP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OkHttp/">OkHttp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Translate/">Translate</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-okhttp/Recipes" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/18/okhttp/Recipes/" class="article-date">
  <time datetime="2017-03-18T11:44:10.000Z" itemprop="datePublished">2017-03-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/18/okhttp/Recipes/">OKHttp Recipes</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://github.com/square/okhttp/wiki/Recipes" target="_blank" rel="external">原文地址</a><br>&emsp;&emsp;我们写了一些建议，来演示如何使用OKHttp来解决一些常见问题。</p>
<h4 id="同步GET"><a href="#同步GET" class="headerlink" title="同步GET"></a>同步GET</h4><p>&emsp;&emsp;下载文件，打印header，打印body。<br>&emsp;&emsp;<code>string()</code>方法对于小文档的响应来说是个既方便有高效的方法。但是如果一个文档太大（大于1M），就不要使用<code>string()</code>方法了，以为他会把整个文档加载到内存中,在这种情况下可以把body当作流来处理。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">private final OkHttpClient client = new OkHttpClient();</div><div class="line">public void run() throws Exception &#123;</div><div class="line">Request request = new Request.Builder()</div><div class="line">    .url(&quot;http://publicobject.com/helloworld.txt&quot;)</div><div class="line">    .build();</div><div class="line"></div><div class="line">Response response = client.newCall(request).execute();</div><div class="line">if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</div><div class="line"></div><div class="line">Headers responseHeaders = response.headers();</div><div class="line">for (int i = 0; i &lt; responseHeaders.size(); i++) &#123;</div><div class="line">System.out.println(responseHeaders.name(i) + &quot;: &quot; + responseHeaders.value(i));</div><div class="line">&#125;</div><div class="line">System.out.println(response.body().string());</div></pre></td></tr></table></figure>
<h4 id="异步GET"><a href="#异步GET" class="headerlink" title="异步GET"></a>异步GET</h4><p> &emsp;&emsp;在工作线程下载文件，响应可读后回调。在响应的header准备好的时候回调。响应体可能仍然阻塞。现在OKHttp没有提供获取响应体的异步API。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">private final OkHttpClient client = new OkHttpClient();</div><div class="line"></div><div class="line">public void run() throws Exception &#123;</div><div class="line">Request request = new Request.Builder()</div><div class="line">    .url(&quot;http://publicobject.com/helloworld.txt&quot;)</div><div class="line">    .build();</div><div class="line"></div><div class="line">client.newCall(request).enqueue(new Callback() &#123;</div><div class="line">    @Override public void onFailure(Call call, IOException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override public void onResponse(Call call, Response response) throws IOException &#123;</div><div class="line">    if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</div><div class="line"></div><div class="line">    Headers responseHeaders = response.headers();</div><div class="line">    for (int i = 0, size = responseHeaders.size(); i &lt; size; i++) &#123;</div><div class="line">        System.out.println(responseHeaders.name(i) + &quot;: &quot; + responseHeaders.value(i));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    System.out.println(response.body().string());</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="访问Header"><a href="#访问Header" class="headerlink" title="访问Header"></a>访问Header</h4><p> &emsp;&emsp;总体上说Header有点像<code>Map&lt;String,String&gt;</code>，每一个字段都有或没有值。但是一些Header允许有多个值，就像Guava的<code>[Multimap](http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/Multimap.html)</code>。<br> 例如HTTP提供多个Vary<code>的值是很常见并且合法的。OKHttp的API在这两种情况下都能轻松使用。
 &amp;emsp;&amp;emsp;当写入请求header的时候使用</code>header(name,value)<code>设置仅有一个的</code>name<code>和</code>value<code>。如果有存在的值，会先移除值再添加。 使用</code>addHeader(name,value)<code>添加header不会移除已经存在的header。
 &amp;emsp;&amp;emsp;当读响应header的时候，</code>header(name)<code>只返回最后一个值，通常也仅有一个。如果没有值，将会返回null。以一个list的方式获取所有的值可以使用</code>headers(name)`。<br> &emsp;&emsp;如果要访问所有的header，可以使用Headers类，支持坐标访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">private final OkHttpClient client = new OkHttpClient();</div><div class="line"></div><div class="line">public void run() throws Exception &#123;</div><div class="line">Request request = new Request.Builder()</div><div class="line">    .url(&quot;https://api.github.com/repos/square/okhttp/issues&quot;)</div><div class="line">    .header(&quot;User-Agent&quot;, &quot;OkHttp Headers.java&quot;)</div><div class="line">    .addHeader(&quot;Accept&quot;, &quot;application/json; q=0.5&quot;)</div><div class="line">    .addHeader(&quot;Accept&quot;, &quot;application/vnd.github.v3+json&quot;)</div><div class="line">    .build();</div><div class="line"></div><div class="line">Response response = client.newCall(request).execute();</div><div class="line">if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</div><div class="line"></div><div class="line">System.out.println(&quot;Server: &quot; + response.header(&quot;Server&quot;));</div><div class="line">System.out.println(&quot;Date: &quot; + response.header(&quot;Date&quot;));</div><div class="line">System.out.println(&quot;Vary: &quot; + response.headers(&quot;Vary&quot;));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用POST发送String请求。"><a href="#使用POST发送String请求。" class="headerlink" title="使用POST发送String请求。"></a>使用POST发送String请求。</h4><p> &emsp;&emsp;使用HTTP的POST给服务发送请求。这个例子发送了一个markdown文档到服务器用来将markdown渲染成HTML。因为整个请求是放在内存中的，所以使用此API的时候避免大文档（小于1M）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public static final MediaType MEDIA_TYPE_MARKDOWN</div><div class="line">    = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;);</div><div class="line"></div><div class="line">private final OkHttpClient client = new OkHttpClient();</div><div class="line"></div><div class="line">public void run() throws Exception &#123;</div><div class="line">String postBody = &quot;&quot;</div><div class="line">    + &quot;Releases\n&quot;</div><div class="line">    + &quot;--------\n&quot;</div><div class="line">    + &quot;\n&quot;</div><div class="line">    + &quot; * _1.0_ May 6, 2013\n&quot;</div><div class="line">    + &quot; * _1.1_ June 15, 2013\n&quot;</div><div class="line">    + &quot; * _1.2_ August 11, 2013\n&quot;;</div><div class="line"></div><div class="line">Request request = new Request.Builder()</div><div class="line">    .url(&quot;https://api.github.com/markdown/raw&quot;)</div><div class="line">    .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody))</div><div class="line">    .build();</div><div class="line"></div><div class="line">Response response = client.newCall(request).execute();</div><div class="line">if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</div><div class="line"></div><div class="line">System.out.println(response.body().string());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用POST发送流"><a href="#使用POST发送流" class="headerlink" title="使用POST发送流"></a>使用POST发送流</h4><p> &emsp;&emsp;使用POST将请求体以流的方式发送。请求体在被写入的时候生成。这个例子直接使用了<code>[Okio](https://github.com/square/okio)</code>的缓冲库。可能你更熟悉<code>OutputStream</code>可以通过<code>BufferedSink.outputStream</code>获取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public static final MediaType MEDIA_TYPE_MARKDOWN</div><div class="line">    = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;);</div><div class="line"></div><div class="line">private final OkHttpClient client = new OkHttpClient();</div><div class="line"></div><div class="line">public void run() throws Exception &#123;</div><div class="line">RequestBody requestBody = new RequestBody() &#123;</div><div class="line">    @Override public MediaType contentType() &#123;</div><div class="line">    return MEDIA_TYPE_MARKDOWN;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override public void writeTo(BufferedSink sink) throws IOException &#123;</div><div class="line">    sink.writeUtf8(&quot;Numbers\n&quot;);</div><div class="line">    sink.writeUtf8(&quot;-------\n&quot;);</div><div class="line">    for (int i = 2; i &lt;= 997; i++) &#123;</div><div class="line">        sink.writeUtf8(String.format(&quot; * %s = %s\n&quot;, i, factor(i)));</div><div class="line">    &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private String factor(int n) &#123;</div><div class="line">    for (int i = 2; i &lt; n; i++) &#123;</div><div class="line">        int x = n / i;</div><div class="line">        if (x * i == n) return factor(x) + &quot; × &quot; + i;</div><div class="line">    &#125;</div><div class="line">    return Integer.toString(n);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Request request = new Request.Builder()</div><div class="line">    .url(&quot;https://api.github.com/markdown/raw&quot;)</div><div class="line">    .post(requestBody)</div><div class="line">    .build();</div><div class="line"></div><div class="line">Response response = client.newCall(request).execute();</div><div class="line">if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</div><div class="line"></div><div class="line">System.out.println(response.body().string());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用POST发送一个文件"><a href="#使用POST发送一个文件" class="headerlink" title="使用POST发送一个文件"></a>使用POST发送一个文件</h4><p> &emsp;&emsp;文件很容易当作一个请求体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public static final MediaType MEDIA_TYPE_MARKDOWN</div><div class="line">    = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;);</div><div class="line"></div><div class="line">private final OkHttpClient client = new OkHttpClient();</div><div class="line"></div><div class="line">public void run() throws Exception &#123;</div><div class="line">File file = new File(&quot;README.md&quot;);</div><div class="line"></div><div class="line">Request request = new Request.Builder()</div><div class="line">    .url(&quot;https://api.github.com/markdown/raw&quot;)</div><div class="line">    .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file))</div><div class="line">    .build();</div><div class="line"></div><div class="line">Response response = client.newCall(request).execute();</div><div class="line">if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</div><div class="line"></div><div class="line">System.out.println(response.body().string());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="发送form-参数"><a href="#发送form-参数" class="headerlink" title="发送form 参数"></a>发送form 参数</h4><p> &emsp;&emsp;使用<code>FormBody.Builder</code>来创建一个同HTML 的<code>form</code>标签方式相同的请求踢。名字和值会被编码成HTML兼容的URL编码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">private final OkHttpClient client = new OkHttpClient();</div><div class="line"></div><div class="line">public void run() throws Exception &#123;</div><div class="line">RequestBody formBody = new FormBody.Builder()</div><div class="line">    .add(&quot;search&quot;, &quot;Jurassic Park&quot;)</div><div class="line">    .build();</div><div class="line">Request request = new Request.Builder()</div><div class="line">    .url(&quot;https://en.wikipedia.org/w/index.php&quot;)</div><div class="line">    .post(formBody)</div><div class="line">    .build();</div><div class="line"></div><div class="line">Response response = client.newCall(request).execute();</div><div class="line">if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</div><div class="line"></div><div class="line">System.out.println(response.body().string());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="发送multipart请求"><a href="#发送multipart请求" class="headerlink" title="发送multipart请求"></a>发送multipart请求</h4><p> &emsp;&emsp;<code>MultipartBody.Builder</code>可以创建和HTML上传文件兼容的请求。每一个multipart请求体自身也是请求体，可以有自己的header。如果提供了，这些header仅描述自身的一部分，例如<code>Content-Dispositon</code>。<code>Content-Type</code>,<code>Content-Length</code>如果可用会自动添加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">private static final String IMGUR_CLIENT_ID = &quot;...&quot;;</div><div class="line">private static final MediaType MEDIA_TYPE_PNG = MediaType.parse(&quot;image/png&quot;);</div><div class="line"></div><div class="line">private final OkHttpClient client = new OkHttpClient();</div><div class="line"></div><div class="line">public void run() throws Exception &#123;</div><div class="line">// Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image</div><div class="line">RequestBody requestBody = new MultipartBody.Builder()</div><div class="line">    .setType(MultipartBody.FORM)</div><div class="line">    .addFormDataPart(&quot;title&quot;, &quot;Square Logo&quot;)</div><div class="line">    .addFormDataPart(&quot;image&quot;, &quot;logo-square.png&quot;,</div><div class="line">        RequestBody.create(MEDIA_TYPE_PNG, new File(&quot;website/static/logo-square.png&quot;)))</div><div class="line">    .build();</div><div class="line"></div><div class="line">Request request = new Request.Builder()</div><div class="line">    .header(&quot;Authorization&quot;, &quot;Client-ID &quot; + IMGUR_CLIENT_ID)</div><div class="line">    .url(&quot;https://api.imgur.com/3/image&quot;)</div><div class="line">    .post(requestBody)</div><div class="line">    .build();</div><div class="line"></div><div class="line">Response response = client.newCall(request).execute();</div><div class="line">if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</div><div class="line"></div><div class="line">System.out.println(response.body().string());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用Gson解析响应JSON"><a href="#使用Gson解析响应JSON" class="headerlink" title="使用Gson解析响应JSON"></a>使用Gson解析响应JSON</h4><p> &emsp;&emsp;<a href="http://code.google.com/p/google-gson/" target="_blank" rel="external">Gson</a>是一个很顺手的转换Java对象和JSON的API。这里我们用它来解析GitHub响应的JSON。<br> &emsp;&emsp;注意，<code>ResponseBody.charStream()</code>使用<code>content-type</code>的响应header来选择解码响应流的字符集，如果没有提供默认使用UTF-8。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">private final OkHttpClient client = new OkHttpClient();</div><div class="line">private final Gson gson = new Gson();</div><div class="line"></div><div class="line">public void run() throws Exception &#123;</div><div class="line">Request request = new Request.Builder()</div><div class="line">    .url(&quot;https://api.github.com/gists/c2a7c39532239ff261be&quot;)</div><div class="line">    .build();</div><div class="line">Response response = client.newCall(request).execute();</div><div class="line">if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</div><div class="line"></div><div class="line">Gist gist = gson.fromJson(response.body().charStream(), Gist.class);</div><div class="line">for (Map.Entry&lt;String, GistFile&gt; entry : gist.files.entrySet()) &#123;</div><div class="line">    System.out.println(entry.getKey());</div><div class="line">    System.out.println(entry.getValue().content);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static class Gist &#123;</div><div class="line">Map&lt;String, GistFile&gt; files;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static class GistFile &#123;</div><div class="line">String content;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="响应缓存"><a href="#响应缓存" class="headerlink" title="响应缓存"></a>响应缓存</h4><p> &emsp;&emsp;为了换成响应需要又一个可读写的缓存目录并且限制缓存的大小。缓存目录应该是私有的，并且非信任的应用无权访问。<br> &emsp;&emsp;同时访问一个缓冲目录回出现错误。大多数应用应该调用一次<code>new OkHttpClient()</code>，配置它的缓存，在其他地方使用统一个实例。否则两个缓存实例会互相损害，损坏换成，可能是你的应用崩溃。<br> &emsp;&emsp;响应缓存使用HTTP的header来配置。如果请求头添加了<code>Cache-Control: max-stale=3600</code>,OKHttp将会使用这些配置。是服务器来配置响应可以被缓存多长时间，通过响应头来配置，例如<code>Cache-Control: max-age=9600</code>。有一些header可以强制换成响应，强制一个网络返回或者强制一个有条件的GET确定缓存是否有效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">private final OkHttpClient client;</div><div class="line"></div><div class="line">public CacheResponse(File cacheDirectory) throws Exception &#123;</div><div class="line">int cacheSize = 10 * 1024 * 1024; // 10 MiB</div><div class="line">Cache cache = new Cache(cacheDirectory, cacheSize);</div><div class="line"></div><div class="line">client = new OkHttpClient.Builder()</div><div class="line">    .cache(cache)</div><div class="line">    .build();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void run() throws Exception &#123;</div><div class="line">Request request = new Request.Builder()</div><div class="line">    .url(&quot;http://publicobject.com/helloworld.txt&quot;)</div><div class="line">    .build();</div><div class="line"></div><div class="line">Response response1 = client.newCall(request).execute();</div><div class="line">if (!response1.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response1);</div><div class="line"></div><div class="line">String response1Body = response1.body().string();</div><div class="line">System.out.println(&quot;Response 1 response:          &quot; + response1);</div><div class="line">System.out.println(&quot;Response 1 cache response:    &quot; + response1.cacheResponse());</div><div class="line">System.out.println(&quot;Response 1 network response:  &quot; + response1.networkResponse());</div><div class="line"></div><div class="line">Response response2 = client.newCall(request).execute();</div><div class="line">if (!response2.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response2);</div><div class="line"></div><div class="line">String response2Body = response2.body().string();</div><div class="line">System.out.println(&quot;Response 2 response:          &quot; + response2);</div><div class="line">System.out.println(&quot;Response 2 cache response:    &quot; + response2.cacheResponse());</div><div class="line">System.out.println(&quot;Response 2 network response:  &quot; + response2.networkResponse());</div><div class="line"></div><div class="line">System.out.println(&quot;Response 2 equals Response 1? &quot; + response1Body.equals(response2Body));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> &emsp;&emsp;为了阻止缓冲可以使用<code>[CacheControl.FORCE_NETWORK](CacheControl.FORCE_NETWORK)</code>.为了阻止网络连接可以使用<code>[CacheControl.FORCE_CACHE](http://square.github.io/okhttp/3.x/okhttp/okhttp3/CacheControl.html#FORCE_CACHE)</code>。警告：如果使用了<code>FORCE_CACHE</code>并且响应需要网络，将会返回<code>504 Unsatisfiable Request</code>。</p>
<h4 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h4><p> &emsp;&emsp;使用<code>Call.cancel()</code>立即取消正在进行的请求。如果一个线程正在写一个请求或者读一个响应将会抛出IOException。当一个请求不在需要的时候使用这个函数来保护网络。例如当用户导航离开应用的时候。同步和异步的请求都可以取消。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);</div><div class="line">private final OkHttpClient client = new OkHttpClient();</div><div class="line"></div><div class="line">public void run() throws Exception &#123;</div><div class="line">Request request = new Request.Builder()</div><div class="line">    .url(&quot;http://httpbin.org/delay/2&quot;) // This URL is served with a 2 second delay.</div><div class="line">    .build();</div><div class="line"></div><div class="line">final long startNanos = System.nanoTime();</div><div class="line">final Call call = client.newCall(request);</div><div class="line"></div><div class="line">// Schedule a job to cancel the call in 1 second.</div><div class="line">executor.schedule(new Runnable() &#123;</div><div class="line">    @Override public void run() &#123;</div><div class="line">    System.out.printf(&quot;%.2f Canceling call.%n&quot;, (System.nanoTime() - startNanos) / 1e9f);</div><div class="line">    call.cancel();</div><div class="line">    System.out.printf(&quot;%.2f Canceled call.%n&quot;, (System.nanoTime() - startNanos) / 1e9f);</div><div class="line">    &#125;</div><div class="line">&#125;, 1, TimeUnit.SECONDS);</div><div class="line"></div><div class="line">try &#123;</div><div class="line">    System.out.printf(&quot;%.2f Executing call.%n&quot;, (System.nanoTime() - startNanos) / 1e9f);</div><div class="line">    Response response = call.execute();</div><div class="line">    System.out.printf(&quot;%.2f Call was expected to fail, but completed: %s%n&quot;,</div><div class="line">        (System.nanoTime() - startNanos) / 1e9f, response);</div><div class="line">&#125; catch (IOException e) &#123;</div><div class="line">    System.out.printf(&quot;%.2f Call failed as expected: %s%n&quot;,</div><div class="line">        (System.nanoTime() - startNanos) / 1e9f, e);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h4><p> &emsp;&emsp;当端点不可达的时候使用超时使请求失败。网络分区可能是客户端连接问题，服务器可用性问题或者其他问题。OKHttp支持连接，读，写超时。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">private final OkHttpClient client;</div><div class="line"></div><div class="line">public ConfigureTimeouts() throws Exception &#123;</div><div class="line">client = new OkHttpClient.Builder()</div><div class="line">    .connectTimeout(10, TimeUnit.SECONDS)</div><div class="line">    .writeTimeout(10, TimeUnit.SECONDS)</div><div class="line">    .readTimeout(30, TimeUnit.SECONDS)</div><div class="line">    .build();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void run() throws Exception &#123;</div><div class="line">Request request = new Request.Builder()</div><div class="line">    .url(&quot;http://httpbin.org/delay/2&quot;) // This URL is served with a 2 second delay.</div><div class="line">    .build();</div><div class="line"></div><div class="line">Response response = client.newCall(request).execute();</div><div class="line">System.out.println(&quot;Response completed: &quot; + response);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="调用前配置"><a href="#调用前配置" class="headerlink" title="调用前配置"></a>调用前配置</h4><p> &emsp;&emsp;所有的HTTP调用配置都会在<code>OkHttpClient</code>中，包括，代理设置，超时和缓存。当需要修改某个调用的配置的时候，使用<code>OKHttpClient.newBuilder()</code>。这个函数会返回共享的连接池，调度器，并且跟原始client相同的配置。在下面这个例子中，一个请求的超时时间是500ms另一个是3000ms。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">private final OkHttpClient client = new OkHttpClient();</div><div class="line"></div><div class="line">public void run() throws Exception &#123;</div><div class="line">Request request = new Request.Builder()</div><div class="line">    .url(&quot;http://httpbin.org/delay/1&quot;) // This URL is served with a 1 second delay.</div><div class="line">    .build();</div><div class="line"></div><div class="line">try &#123;</div><div class="line">    // Copy to customize OkHttp for this request.</div><div class="line">    OkHttpClient copy = client.newBuilder()</div><div class="line">        .readTimeout(500, TimeUnit.MILLISECONDS)</div><div class="line">        .build();</div><div class="line"></div><div class="line">    Response response = copy.newCall(request).execute();</div><div class="line">    System.out.println(&quot;Response 1 succeeded: &quot; + response);</div><div class="line">&#125; catch (IOException e) &#123;</div><div class="line">    System.out.println(&quot;Response 1 failed: &quot; + e);</div><div class="line">&#125;</div><div class="line"></div><div class="line">try &#123;</div><div class="line">    // Copy to customize OkHttp for this request.</div><div class="line">    OkHttpClient copy = client.newBuilder()</div><div class="line">        .readTimeout(3000, TimeUnit.MILLISECONDS)</div><div class="line">        .build();</div><div class="line"></div><div class="line">    Response response = copy.newCall(request).execute();</div><div class="line">    System.out.println(&quot;Response 2 succeeded: &quot; + response);</div><div class="line">&#125; catch (IOException e) &#123;</div><div class="line">    System.out.println(&quot;Response 2 failed: &quot; + e);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="处理认证"><a href="#处理认证" class="headerlink" title="处理认证"></a>处理认证</h4><p> &emsp;&emsp;OKHttp会自动重试认证请求。当响应是<code>401 Not Authorized</code>,<code>Authenticator</code>需要用来提供凭证。将会重新实现一个带有凭证的请求，如果没有凭证可用跳过重试，返回null。<br> &emsp;&emsp;使用<code>Response.challenges()</code>来获取任何认证口令的方案和域。当使用<code>Basic</code>认证的时候使用<code>Credentials.basic(username,password)</code>来编码一个header。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">private final OkHttpClient client;</div><div class="line"></div><div class="line">public Authenticate() &#123;</div><div class="line">client = new OkHttpClient.Builder()</div><div class="line">    .authenticator(new Authenticator() &#123;</div><div class="line">        @Override public Request authenticate(Route route, Response response) throws IOException &#123;</div><div class="line">        System.out.println(&quot;Authenticating for response: &quot; + response);</div><div class="line">        System.out.println(&quot;Challenges: &quot; + response.challenges());</div><div class="line">        String credential = Credentials.basic(&quot;jesse&quot;, &quot;password1&quot;);</div><div class="line">        return response.request().newBuilder()</div><div class="line">            .header(&quot;Authorization&quot;, credential)</div><div class="line">            .build();</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">    .build();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void run() throws Exception &#123;</div><div class="line">Request request = new Request.Builder()</div><div class="line">    .url(&quot;http://publicobject.com/secrets/hellosecret.txt&quot;)</div><div class="line">    .build();</div><div class="line"></div><div class="line">Response response = client.newCall(request).execute();</div><div class="line">if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</div><div class="line"></div><div class="line">System.out.println(response.body().string());</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mashuai.github.io/2017/03/18/okhttp/Recipes/" data-id="cj0ge8y490018q0itz82pi662" class="article-share-link">Share</a>
      
        <a href="https://mashuai.github.io/2017/03/18/okhttp/Recipes/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/">HTTP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OKHttp/">OKHttp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Translate/">Translate</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-okhttp/connections" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/18/okhttp/connections/" class="article-date">
  <time datetime="2017-03-18T11:05:48.000Z" itemprop="datePublished">2017-03-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/18/okhttp/connections/">OKHttp connections</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://github.com/square/okhttp/wiki/Connections" target="_blank" rel="external">原文地址</a><br>&emsp;&emsp;虽然只提供了URL，但是OKHttp会使用URL，Address，Route三种方式来连接服务器。</p>
<h4 id="URLS"><a href="#URLS" class="headerlink" title="URLS"></a>URLS</h4><p>&emsp;&emsp;URLs例如（<a href="https://github.com/square/okhttp" target="_blank" rel="external">https://github.com/square/okhttp</a>) 是HTTP和Internet的基础。除了是一个表示互联网一切的命名方案，也指定了如何访问Web资源。<br>URLs是抽象的：</p>
<ul>
<li>它指出，调用可以是纯文本（http）或者加密（https），但是并没有指定一种加密算法。也没有指定如何验证各个端点的证书(<a href="http://developer.android.com/reference/javax/net/ssl/HostnameVerifier.html" target="_blank" rel="external">HostnameVerifier</a>)，或者是哪个证书可信(<a href="http://developer.android.com/reference/org/apache/http/conn/ssl/SSLSocketFactory.html" target="_blank" rel="external">SSLSocketFactory</a>)</li>
<li><p>它为指定是否需要使用代理服务器以及代理服务器如何授权。<br>&emsp;&emsp;它也是具体的，每个URL标识一个具体的路径（/square/okhttp)和查询（?q=sharks&amp;lang=en)。每个服务器有很多URL。</p>
<h4 id="Addresses"><a href="#Addresses" class="headerlink" title="Addresses"></a>Addresses</h4><p>&emsp;&emsp;Address指定了一个服务器（例如：github.com），以及连接服务器必要的所有的静态配置，包括：端口号，HTTPS设置，优先协议（例如，HTTP／2，SPDY）。<br>&emsp;&emsp;URL使用了相同的Address，底层也可能实用了相同的TCP链接。复用连接可以提高性能：低延迟，高吞吐（<a href="http://www.igvita.com/2011/10/20/faster-web-vs-tcp-slow-start/" target="_blank" rel="external">TCP 慢启动</a>)，低电量。OKHttp使用<a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/ConnectionPool.html" target="_blank" rel="external">ConnectionPool</a>自动复用HTTP／1.x连接，多路复用HTT／2和SPDY的连接。<br>&emsp;&emsp;在OKHttp，address的一些字段来源于URL（协议，主机名，端口），剩下的来自<a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/OkHttpClient.html" target="_blank" rel="external">OKHttpClient</a>。</p>
<h4 id="Routes"><a href="#Routes" class="headerlink" title="Routes"></a>Routes</h4><p>&emsp;&emsp;Route提供了连接服务器必要的动态信息。包括，具体的IP地址（通过DNS查询），具体使用那个代理（<a href="http://developer.android.com/reference/java/net/ProxySelector.html" target="_blank" rel="external">ProxySelector</a>），协n哪个TLS版本（HTTPS).<br>&emsp;&emsp;一个服务器可能有多条路有信息。例如：多台服务器部署在多个数据中心，DNS查询返回多个IP地址。</p>
<h4 id="Connections"><a href="#Connections" class="headerlink" title="Connections"></a>Connections</h4><p>&emsp;&emsp;当发起一个URL的请求的时候：</p>
<ol>
<li>使用URL和OKHttpCLient确定具体的<strong>Address</strong>。这个地址明确如何连接服务器。</li>
<li>尝试从<strong>连接池</strong>中查找具体Address的连接。</li>
<li>如果未找到有效的连接，使用Route来尝试获取。一般这样意味着通过DNS或去IP地址。然后，如果需要，选择一个TLS的版本和代理服务器。</li>
<li>如果是一个新的Route，要么使用Socket直连，TLS隧道（HTTS方式），或者直接使用TLS。也会进行必要的TLS握手。</li>
<li>发送请求，接受响应。<br>&emsp;&emsp;如果连接发生错误，OKHttp会选择另一个路由重试。这样OKHttp就可以在服务器端一些地址无法访问的时候恢复访问。同时如果连接池的连接失效或者常识的TLS 版本不支持也很有用。<br>&emsp;&emsp;当响应接收到了之后，连接会放回到连接池以便之后使用。连接在一段时间过期后回被移除连接池。</li>
</ol>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mashuai.github.io/2017/03/18/okhttp/connections/" data-id="cj0ge8y4f001bq0itd8j8kawk" class="article-share-link">Share</a>
      
        <a href="https://mashuai.github.io/2017/03/18/okhttp/connections/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/">HTTP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OKHttp/">OKHttp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Translate/">Translate</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-okhttp/calls" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/18/okhttp/calls/" class="article-date">
  <time datetime="2017-03-18T07:10:03.000Z" itemprop="datePublished">2017-03-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/18/okhttp/calls/">OKHttp的调用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://github.com/square/okhttp/wiki/Calls" target="_blank" rel="external">原文地址</a></p>
<p>&emsp;&emsp;HTTP客户端的任务是接受请求和产生响应。理论很简单，但是实战的时候就有点棘手了。</p>
<h4 id="Requests"><a href="#Requests" class="headerlink" title="Requests"></a>Requests</h4><p>&emsp;&emsp;每一个HTTP请求都包含一个URL，一个方法（例如，GET，POST）和一些headers。请求同时可以包含一个特定类型的数据流作为body。</p>
<h4 id="Responses"><a href="#Responses" class="headerlink" title="Responses"></a>Responses</h4><p>&emsp;&emsp;Response 通过一个一个状态码（例如，200 成功，404未找到），headers，和一个可选的Body来响应请求。</p>
<h5 id="重写请求"><a href="#重写请求" class="headerlink" title="重写请求"></a>重写请求</h5><p>&emsp;&emsp;当使用OkHttp发送HTTP请求的时候，可以在高层次描述这个请求：通过这个URL和这些headers来获取响应。为了准确和更高的效率，OKHttp会在发送之前重现请求。<br>&emsp;&emsp;OkHttp将会添加原请求没有的header，包括<code>Content-length</code>,<code>Transfer-Encoding</code>,<code>User-Agent</code>,<code>Host</code>,<code>Connection</code>，<code>Content-Type</code>。除非已经提供了，否则OKHttp回会添加 <code>Acceept-Encoding</code>来压缩响应。如果有Cookie，也会添加<code>Cookie</code>。<br>&emsp;&emsp;有些请求会缓存响应。当被缓存的响应过期后，OKHttp会发送一个有条件的GET请求来获取新的响应，如果新现在的比缓存的响应更新，将会更新缓存过的响应。这要求<code>If-Modified-Since</code>和<code>If-None-Match</code>添加到headers中。</p>
<h5 id="重写响应"><a href="#重写响应" class="headerlink" title="重写响应"></a>重写响应</h5><p>&emsp;&emsp;如果透明压缩启用了，OKHttp将会把<code>Content-Encoding</code>和<code>Content-Length</code>从headers中移除，因为他们不是用来解压缩的。<br>&emsp;&emsp;如果条件GET请求成功，从网上下载的响应和缓存的响应根据Spec合并。</p>
<h5 id="后续请求"><a href="#后续请求" class="headerlink" title="后续请求"></a>后续请求</h5><p>&emsp;&emsp;当请求的URL被转移了，web server 将会返回一个302的状态码来表示这个文档的新URL，OKHttp将会重定向到新的URL获取最终的响应。<br>&emsp;&emsp;如果响应需要认证，OKHttp将会使用<code>Authenticator</code>（如果提供了一个）来认证。如果认证器提供了凭证，请求回使用凭证重试。</p>
<h5 id="重试请求"><a href="#重试请求" class="headerlink" title="重试请求"></a>重试请求</h5><p>&emsp;&emsp;有时连接失败，例如：连接池过期断开链接，或者无法连接服务器。OKHttp会通过不同的可用路由来重试请求。</p>
<h4 id="calls"><a href="#calls" class="headerlink" title="calls"></a>calls</h4><p>&emsp;&emsp;通过重写，重定向，继续请求和重试，一个简单的请求可能会产生很多请求和响应。OKHttp使用<code>call</code>建立一个不管多少中间请求和响应的任务模型。总的来说这不多。但是了解代码将会继续工作，不管是URL重定向或者是转移故障其他IP。<br>&emsp;&emsp;call有两种工作方</p>
<ul>
<li>同步：线程将会阻塞道到响应可读。</li>
<li>异步：将请求加入到其他线程的队列，当响应可读诗时，会在其他的线程获取回调。<br>&emsp;&emsp;请求调用可以在任何线程取消。如果调用未完成，这个请求将会失败。当调用取消时，在先请求踢体或者读响应体的代码将会跑出IOException的异常。<h5 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h5>&emsp;&emsp;对于同步调用，将会由自身线程控制多少并发请求。太多并发连接浪费资源，太少又回有高延迟。<br>&emsp;&emsp;对于异步来说，Dispatcher实现了最大并发的策略。可以设置没个服务器的最大并发（默认是5）和总体的并发（默认64）。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mashuai.github.io/2017/03/18/okhttp/calls/" data-id="cj0ge8y4c0019q0ittw0ah1yj" class="article-share-link">Share</a>
      
        <a href="https://mashuai.github.io/2017/03/18/okhttp/calls/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/">HTTP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OkHttp/">OkHttp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Translate/">Translate</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-为Go-Web-App-创建一个主页面" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/14/为Go-Web-App-创建一个主页面/" class="article-date">
  <time datetime="2015-11-14T09:59:00.000Z" itemprop="datePublished">2015-11-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/14/为Go-Web-App-创建一个主页面/">为Go Web App 创建一个主页面</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://sanatgersappa.blogspot.com/2013/11/creating-master-page-for-your-go-web-app.html" target="_blank" rel="external">原文地址</a></p>
<p>&emsp;&emsp; 大多数web app都有一个相同的布局。这个布局可能包含一个header或者footer，甚至可能包含一个导航菜单。Go的标准库提供一个简单的方式来创建这些基本元素，通过被不同的页面重用，创建出模板页的效果。<br>&emsp;&emsp; 这个简单的例子来解释如何实现的：<br>&emsp;&emsp; 让我们来创建一个简单的包含两个view的web app，一个是 main 一个是about。这两个view都有相同的header和footer。<br>&emsp;&emsp; header模板的代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&#123; &#123; define "header" &#125;&#125;</div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">        &lt;title&gt;&#123; &#123;.Title&#125;&#125;&lt;/title&gt;</div><div class="line">        &lt;link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css"&gt;</div><div class="line">        &lt;link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap-theme.min.css"&gt;</div><div class="line">        &lt;style type="text/css"&gt;</div><div class="line">            body &#123;padding-bottom: 70px;&#125;</div><div class="line">            .content &#123;margin:10px;&#125;</div><div class="line">        &lt;/style&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;body&gt;</div><div class="line">        &lt;nav class="navbar navbar-default" role="navigation"&gt;</div><div class="line">          &lt;div class="navbar-header"&gt;</div><div class="line">            &lt;a class="navbar-brand" href="/"&gt;Go App&lt;/a&gt;</div><div class="line">          &lt;/div&gt;</div><div class="line">          &lt;div class="collapse navbar-collapse navbar-ex1-collapse"&gt;  </div><div class="line">            &lt;ul class="nav navbar-nav"&gt;</div><div class="line">                &lt;li&gt;&lt;a href="/"&gt;Main&lt;/a&gt;&lt;/li&gt;</div><div class="line">                &lt;li&gt;&lt;a href="/about"&gt;About&lt;/a&gt;&lt;/li&gt;</div><div class="line">            &lt;/ul&gt;</div><div class="line">          &lt;/div&gt;</div><div class="line">        &lt;/nav&gt;</div><div class="line">&#123; &#123; end &#125;&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; footer模板的代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123; &#123; define "footer" &#125;&#125;</div><div class="line">        &lt;p class="navbar-text navbar-fixed-bottom"&gt;Go Rocks!&lt;/p&gt;    </div><div class="line">        &lt;script src="//netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"&gt;&lt;/script&gt;</div><div class="line">    &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div><div class="line">&#123; &#123; end &#125;&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; main 模板的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123; &#123;define &quot;main&quot;&#125;&#125;</div><div class="line">&#123; &#123; template &quot;header&quot; .&#125;&#125;</div><div class="line">&lt;div class=&quot;content&quot;&gt;</div><div class="line">    &lt;h2&gt;Main&lt;/h2&gt;</div><div class="line">    &lt;div&gt;This is the Main page&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&#123; &#123;template &quot;footer&quot; .&#125;&#125;</div><div class="line">&#123; &#123; end&#125;&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; about 模板的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123; &#123;define &quot;about&quot;&#125;&#125;</div><div class="line">&#123; &#123; template &quot;header&quot; .&#125;&#125;</div><div class="line">&lt;div class=&quot;content&quot;&gt;</div><div class="line">    &lt;h2&gt;About&lt;/h2&gt;</div><div class="line">    &lt;div&gt;This is the About page&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&#123; &#123;template &quot;footer&quot; .&#125;&#125;</div><div class="line">&#123; &#123; end&#125;&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; 服务器代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">    &quot;html/template&quot;</div><div class="line">    &quot;net/http&quot;</div><div class="line">)</div><div class="line"></div><div class="line">//Compile templates on start</div><div class="line">var templates = template.Must(template.ParseFiles(&quot;header.html&quot;, &quot;footer.html&quot;, &quot;main.html&quot;, &quot;about.html&quot;))</div><div class="line"></div><div class="line">//A Page structure</div><div class="line">type Page struct &#123;</div><div class="line">    Title string</div><div class="line">&#125;</div><div class="line"></div><div class="line">//Display the named template</div><div class="line">func display(w http.ResponseWriter, tmpl string, data interface&#123;&#125;) &#123;</div><div class="line">    templates.ExecuteTemplate(w, tmpl, data)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//The handlers.</div><div class="line">func mainHandler(w http.ResponseWriter, r *http.Request) &#123;</div><div class="line">    display(w, &quot;main&quot;, &amp;Page&#123;Title: &quot;Home&quot;&#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func aboutHandler(w http.ResponseWriter, r *http.Request) &#123;</div><div class="line">    display(w, &quot;about&quot;, &amp;Page&#123;Title: &quot;About&quot;&#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    http.HandleFunc(&quot;/&quot;, mainHandler)</div><div class="line">    http.HandleFunc(&quot;/about&quot;, aboutHandler)</div><div class="line"></div><div class="line">    //Listen on port 8080</div><div class="line">    http.ListenAndServe(&quot;:8080&quot;, nil)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; 每一个模板页都有一个 <code>{ { define &quot;name&quot; }}</code>的命令来定义模板的名字。main和about页面通过<code>{ { template &quot;name&quot; }}</code>来包含header和footer。<code>.</code> 出入上下文来命名模板。现在，不管main和about页面如何执行，他们的页面都会包含header和footer。<br>&emsp;&emsp; 两个页面的结果如下：</p>
<p><img src="https://raw.githubusercontent.com/mashuai/hexo-blog/master/goweb/main.png" alt="main"><br><img src="https://raw.githubusercontent.com/mashuai/hexo-blog/master/goweb/about.png" alt="about">  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mashuai.github.io/2015/11/14/为Go-Web-App-创建一个主页面/" data-id="cj0ge8y2w0008q0ityxnkemyx" class="article-share-link">Share</a>
      
        <a href="https://mashuai.github.io/2015/11/14/为Go-Web-App-创建一个主页面/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go/">Go</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Translate/">Translate</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-http-Handler-与Go的错误处理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/12/http-Handler-与Go的错误处理/" class="article-date">
  <time datetime="2015-11-12T13:24:57.000Z" itemprop="datePublished">2015-11-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/12/http-Handler-与Go的错误处理/">http.Handler 与Go的错误处理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://elithrar.github.io/article/http-handler-error-handling-revisited/" target="_blank" rel="external">原文地址</a></p>
<p>&emsp;&emsp; 在之前我写过一篇关于通过使用<code>http.HandlerFunc</code>来实现一个定制handler类型用来避免一些平常的错误的<a href="http://elithrar.github.io/article/custom-handlers-avoiding-globals/" target="_blank" rel="external">文章</a>。<code>func MyHandler(w http.ResponseWriter, r *http.Request)</code>的签名经常可以看到。这是一个有用的通用的包含一些基本功能的handler类型，但是和其他事情一样，也有一些不足：</p>
<ul>
<li>当你想要在一个handler中停止处理的时候，必须记得显示的调用一个return。这个在当你想要跑出一个从定向（301、302），未找到（404）或者服务器端错误（500）的状态的时候是很平常的。如果不这么做可能会引起一些微妙的错误（函数会继续执行），因为函数不需要一个返回值，编译器也不会警告你。</li>
<li>不容易传递额外的参数（例如，数据库连接池，配置）。你最后不得不实用一系列的全局变量（不算太坏，但是跟踪他们会导致难以扩展）或者将他们存到请求上下文中，然后每次都从其取出。这样做很笨重。</li>
<li>一直在不断的重复同样的语句。想要记录数据库包返回的错误？既可以再每个查询方法中调用<code>log.Printf</code>，也可以再每个handler中返回错误。如果你的handler可以返回给一个集中记录错误的函数，并且跑出一个500的错误就更好了。</li>
</ul>
<p>&emsp;&emsp; 我以前的方法中使用了<code>func(http.ResponseWriter, *http.Request)</code>签名。这已经被证明是一个简介的方式，但是有个奇怪的地方是，返回一个无错误的状态，例如，200,302,303往往是多余的，因为要么你已经在其他地方设置了，要么就是没用的。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">func SomeHandler(w http.ResponseWriter, r *http.Request) (int, error) &#123;</div><div class="line">    db, err := someDBcall()</div><div class="line">    if err != nil &#123;</div><div class="line">        // This makes sense.</div><div class="line">        return 500, err</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if user.LoggedIn &#123;</div><div class="line">        http.Redirect(w, r, &quot;/dashboard&quot;, 302)</div><div class="line">        // Superfluous! Our http.Redirect function handles the 302, not </div><div class="line">        // our return value (which is effectively ignored).</div><div class="line">        return 302, nil</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;看起来还行，但是我们可以做的更好</p>
<h3 id="一些区别"><a href="#一些区别" class="headerlink" title="一些区别"></a>一些区别</h3><p>&emsp;&emsp; 那么我们应该如何改进它？我们先列出代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">package handler</div><div class="line"></div><div class="line">// Error represents a handler error. It provides methods for a HTTP status </div><div class="line">// code and embeds the built-in error interface.</div><div class="line">type Error interface &#123;</div><div class="line">    error</div><div class="line">    Status() int</div><div class="line">&#125;</div><div class="line"></div><div class="line">// StatusError represents an error with an associated HTTP status code.</div><div class="line">type StatusError struct &#123;</div><div class="line">    Code int</div><div class="line">    Err  error</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Allows StatusError to satisfy the error interface.</div><div class="line">func (se StatusError) Error() string &#123;</div><div class="line">    return se.Err.Error()</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Returns our HTTP status code.</div><div class="line">func (se StatusError) Status() int &#123;</div><div class="line">    return se.Code</div><div class="line">&#125;</div><div class="line"></div><div class="line">// A (simple) example of our application-wide configuration.</div><div class="line">type Env struct &#123;</div><div class="line">    DB   *sql.DB</div><div class="line">    Port string</div><div class="line">    Host string</div><div class="line">&#125;</div><div class="line"></div><div class="line">// The Handler struct that takes a configured Env and a function matching</div><div class="line">// our useful signature.</div><div class="line">type Handler struct &#123;</div><div class="line">    *Env</div><div class="line">    H func(e *Env, w http.ResponseWriter, r *http.Request) error</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ServeHTTP allows our Handler type to satisfy http.Handler.</div><div class="line">func (h Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</div><div class="line">    err := h.H(h.Env, w, r)</div><div class="line">    if err != nil &#123;</div><div class="line">        switch e := err.(type) &#123;</div><div class="line">        case Error:</div><div class="line">            // We can retrieve the status here and write out a specific</div><div class="line">            // HTTP status code.</div><div class="line">            log.Printf(&quot;HTTP %d - %s&quot;, e.Status(), e)</div><div class="line">            http.Error(w, e.Error(), e.Status())</div><div class="line">        default:</div><div class="line">            // Any error types we don&apos;t specifically look out for default</div><div class="line">            // to serving a HTTP 500</div><div class="line">            http.Error(w, http.StatusText(http.StatusInternalServerError),</div><div class="line">                http.StatusInternalServerError)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; 上面的代码不言自明，但是要说明一下一些突出的观点：</p>
<ul>
<li>我们自定义了一个<code>Error</code>类型（接口），他内嵌了Go的内建的error接口，同时提供了一个<code>Status() int</code>方法。</li>
<li>我们提供了一个简单的<code>StatusError</code>类型（结构体），它满足<code>handler.Error</code>的接口。StatusError接受一个HTTP的状态码（int类型），一个可以让我们包装错误用来记录或者查询的error类型。</li>
<li>我们的<code>ServeHTTP</code>方法包好了一个”e := err.(type)”的类型断言，它可以测试我们需要处理的错误，允许我们处理那些特别的错误。在这个例子中，他是只是一个<code>handler.Error</code>类型。其他的错误，例如其他包中的错误想net.Error，或者其他我们定义的额外的错误，如果想要检查，同样也可以检查。</li>
</ul>
<p>&emsp;&emsp; 如果我们不想捕捉那些错误，那么<code>default</code>将会默认捕捉到。记住一点，<code>ServeHTTP</code>可以使我们的Handler类型满足http.Handler接口，这样他就可以在任何使用http.Handler的地方使用了，例如Go的net/http包或者所有的其他的第三方框架。这样使得定制的handler更有用，他们用起来很灵活。<br>&emsp;&emsp; 注意 net 包处理事情很简单。它又一个net.Error的接口，内嵌了内建的error接口。一些具体的类型实现了它。函数返回的具体类型跟错误的类型相同（DNS错误，解析错误等）。再datastore 包中定义的DBError有一个Query() string 方法，可以很好的解释。</p>
<h3 id="所有示例"><a href="#所有示例" class="headerlink" title="所有示例"></a>所有示例</h3><p>&emsp;&emsp; 它最后是什么样子的？我们是否可以将其分到不同的包中？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">package handler</div><div class="line"></div><div class="line">import (</div><div class="line">    &quot;net/http&quot;</div><div class="line">)</div><div class="line"></div><div class="line">// Error represents a handler error. It provides methods for a HTTP status </div><div class="line">// code and embeds the built-in error interface.</div><div class="line">type Error interface &#123;</div><div class="line">    error</div><div class="line">    Status() int</div><div class="line">&#125;</div><div class="line"></div><div class="line">// StatusError represents an error with an associated HTTP status code.</div><div class="line">type StatusError struct &#123;</div><div class="line">    Code int</div><div class="line">    Err  error</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Allows StatusError to satisfy the error interface.</div><div class="line">func (se StatusError) Error() string &#123;</div><div class="line">    return se.Err.Error()</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Returns our HTTP status code.</div><div class="line">func (se StatusError) Status() int &#123;</div><div class="line">    return se.Code</div><div class="line">&#125;</div><div class="line"></div><div class="line">// A (simple) example of our application-wide configuration.</div><div class="line">type Env struct &#123;</div><div class="line">    DB   *sql.DB</div><div class="line">    Port string</div><div class="line">    Host string</div><div class="line">&#125;</div><div class="line"></div><div class="line">// The Handler struct that takes a configured Env and a function matching</div><div class="line">// our useful signature.</div><div class="line">type Handler struct &#123;</div><div class="line">    *Env</div><div class="line">    H func(e *Env, w http.ResponseWriter, r *http.Request) error</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ServeHTTP allows our Handler type to satisfy http.Handler.</div><div class="line">func (h Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</div><div class="line">    err := h.H(h.Env, w, r)</div><div class="line">    if err != nil &#123;</div><div class="line">        switch e := err.(type) &#123;</div><div class="line">        case Error:</div><div class="line">            // We can retrieve the status here and write out a specific</div><div class="line">            // HTTP status code.</div><div class="line">            log.Printf(&quot;HTTP %d - %s&quot;, e.Status(), e)</div><div class="line">            http.Error(w, e.Error(), e.Status())</div><div class="line">        default:</div><div class="line">            // Any error types we don&apos;t specifically look out for default</div><div class="line">            // to serving a HTTP 500</div><div class="line">            http.Error(w, http.StatusText(http.StatusInternalServerError),</div><div class="line">                http.StatusInternalServerError)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func GetIndex(env *Env, w http.ResponseWriter, r *http.Request) error &#123;</div><div class="line">    users, err := env.DB.GetAllUsers()</div><div class="line">    if err != nil &#123;</div><div class="line">        // We return a status error here, which conveniently wraps the error</div><div class="line">        // returned from our DB queries. We can clearly define which errors </div><div class="line">        // are worth raising a HTTP 500 over vs. which might just be a HTTP </div><div class="line">        // 404, 403 or 401 (as appropriate). It&apos;s also clear where our </div><div class="line">        // handler should stop processing by returning early.</div><div class="line">        return StatusError&#123;500, err&#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    fmt.Fprintf(w, &quot;%+v&quot;, users)</div><div class="line">    return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; main包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">    &quot;net/http&quot;</div><div class="line">    &quot;github.com/you/somepkg/handler&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    db, err := sql.Open(&quot;connectionstringhere&quot;)</div><div class="line">    if err != nil &#123;</div><div class="line">          log.Fatal(err)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Initialise our app-wide environment with the services/info we need.</div><div class="line">    env := &amp;handler.Env&#123;</div><div class="line">        DB: db,</div><div class="line">        Port: os.Getenv(&quot;PORT&quot;),</div><div class="line">        Host: os.Getenv(&quot;HOST&quot;),</div><div class="line">        // We might also have a custom log.Logger, our </div><div class="line">        // template instance, and a config struct as fields </div><div class="line">        // in our Env struct.</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Note that we&apos;re using http.Handle, not http.HandleFunc. The </div><div class="line">    // latter only accepts the http.HandlerFunc type, which is not </div><div class="line">    // what we have here.</div><div class="line">    http.Handle(&quot;/&quot;, handler.Handler&#123;env, handler.GetIndex&#125;)</div><div class="line"></div><div class="line">    // Logs the error if ListenAndServe fails.</div><div class="line">    log.Fatal(http.ListenAndServe(&quot;:8000&quot;, nil))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; 在实际使用时，会将handler和Env放入不同的包中，这里只是为了简单放在了同一个包中。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mashuai.github.io/2015/11/12/http-Handler-与Go的错误处理/" data-id="cj0ge8y2u0007q0ito8yph7w5" class="article-share-link">Share</a>
      
        <a href="https://mashuai.github.io/2015/11/12/http-Handler-与Go的错误处理/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go/">Go</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Translate/">Translate</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-使用Go开发HTTP中间件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/12/使用Go开发HTTP中间件/" class="article-date">
  <time datetime="2015-11-12T04:07:49.000Z" itemprop="datePublished">2015-11-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/12/使用Go开发HTTP中间件/">使用Go开发HTTP中间件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://justinas.org/writing-http-middleware-in-go/" target="_blank" rel="external">原文地址</a></p>
<p>&emsp;&emsp; 再web开发的背景下，“中间件”通常意思是“包装原始应用并添加一些额外的功能的应用的一部分”。这个概念似乎总是不被人理解，但是我认为中间件非常棒。<br>&emsp;&emsp; 首先，一个好的中间件有一个责任就是可插拔并且自足。这就意味着你可以在接口级别嵌入你的中间件他就能直接运行。它不会影响你编码方式，不是框架，仅仅是你请求处理里面的一层而已。完全没必要重写你的代码，如果你想使用中间件的一个功能，你就帮他插入到那里，如果不想使用了，就可以直接移除。<br>&emsp;&emsp; 纵观Go语言，中间件是非常普遍的，即使在标准库中。虽然开始的时候不会那么明显，在标准库<code>net/http</code>中的函数<code>StripText</code>或者<code>TimeoutHandler</code>就是我们要定义和的中间件的样子，处理请求和相应的时候他们包装你的handler，并处理一些额外的步骤。<br>&emsp;&emsp; 我最近写的Go包<a href="https://github.com/justinas/nosurf" target="_blank" rel="external">nosurf</a>同样也是个中间件。我特意将他从头开始设计。在大多数情况下，你不需要在应用层担心CSRF攻击，nosurf像其他的中间件一样可以自足，并且和<code>net/http</code>的接口无缝衔接。<br>&emsp;&emsp; 同样你还可以使用中间件做：</p>
<ul>
<li>隐藏长度防止缓冲攻击</li>
<li>速度限制</li>
<li>屏蔽爬虫</li>
<li>提供调试信息</li>
<li>添加HSTS，X-Frame-Options头</li>
<li>从错误中恢复</li>
<li>等等</li>
</ul>
<h3 id="编写一个简单的中间件"><a href="#编写一个简单的中间件" class="headerlink" title="编写一个简单的中间件"></a>编写一个简单的中间件</h3><p>&emsp;&emsp; 我们的第一个例子是写一个只允许一个域名下的用户访问的中间件，通过HTTP的<code>HOST</code>header实现。这样的中间件可以防止<a href="http://www.skeletonscribe.net/2013/05/practical-http-host-header-attacks.html" target="_blank" rel="external">主机欺骗攻击</a>。</p>
<h3 id="类型的机构"><a href="#类型的机构" class="headerlink" title="类型的机构"></a>类型的机构</h3><p>&emsp;&emsp; 首先我们定义一个结构体，叫做<code>SingleHost</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">type SingleHost struct &#123;</div><div class="line">    handler     http.Handler</div><div class="line">    allowedHost string</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; 它只包含两个field。</p>
<ul>
<li>如果是一个可用的Host，那么我们会调用嵌入的handler。</li>
<li>allowedHost 就是允许的Host。<br>&emsp;&emsp; 因为我们将其首字母小写，因此他们只对本包可见。我们需要给它定义已给构造函数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func NewSingleHost(handler http.Handler, allowedHost string) *SingleHost &#123;</div><div class="line">    return &amp;SingleHost&#123;handler: handler, allowedHost: allowedHost&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h3><p>&emsp;&emsp; 现在需要实现真正的逻辑功能了。想要实现<code>http.Handler</code>，我们只需要实现他的一个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">type Handler interface &#123;</div><div class="line">        ServeHTTP(ResponseWriter, *Request)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; 实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">func (s *SingleHost) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</div><div class="line">    host := r.Host</div><div class="line">    if host == s.allowedHost &#123;</div><div class="line">        s.handler.ServeHTTP(w, r)</div><div class="line">    &#125; else &#123;</div><div class="line">        w.WriteHeader(403)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ServeHTTP</code>只是检查请求的Host：</p>
<ul>
<li>如果Host和配置的allowed一直，那么调用handler的ServeHTTP。</li>
<li>如果不一直返回403<br>&emsp;&emsp;对于后一种情况，不仅不会得到应答，设置不知道有这个请求。<br>&emsp;&emsp;现在我们已经开发哈了中间件，只需要将其插入到需要的地方。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">singleHosted = NewSingleHost(myHandler, &quot;example.com&quot;)</div><div class="line">http.ListenAndServe(&quot;:8080&quot;, singleHosted)</div></pre></td></tr></table></figure>
<h3 id="另一种方式"><a href="#另一种方式" class="headerlink" title="另一种方式"></a>另一种方式</h3><p>&emsp;&emsp; 我们刚刚写的那个中间件很简单，它只有15行代码。写这样的中间件，可以使用样板方法。由于Go支持函数为一等公民和闭包，并且有<code>http.HandlerFunc</code>包装函数，我们可以通过他创建一个中间件，而不是将其放入到一个结构体中。下面是这个中间件的写法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">func SingleHost(handler http.Handler, allowedHost string) http.Handler &#123;</div><div class="line">    ourFunc := func(w http.ResponseWriter, r *http.Request) &#123;</div><div class="line">        host := r.Host</div><div class="line">        if host == allowedHost &#123;</div><div class="line">            handler.ServeHTTP(w, r)</div><div class="line">        &#125; else &#123;</div><div class="line">            w.WriteHeader(403)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return http.HandlerFunc(ourFunc)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp; 我们定义了一个简单的函数<code>SingleHost</code>，它包装了<code>Handler</code>和允许的Host，在其内部我们实现了一个跟上面中间件类似的功能。我们内部的函数就是一个闭包，因此他可以访问外部函数的变量。最终HandlerFunc让我们可以将其变为Handler。<br>&emsp;&emsp; 觉得是使用HandlerFunc还是自己实现一个http.Handler完全取决于你自己。对于简单的情况，一个简单的函数就完全够了。如果你的中间件越来越多，那么就可以考虑实现自己的结构并把它们分开。<br>&emsp;&emsp; 同时标准库同时使用了两种功能。<code>StripPrefix</code>使用的是HandlerFunc，TimeoutHandler使用的是自定义的结构体。</p>
<h3 id="一个更复杂的例子"><a href="#一个更复杂的例子" class="headerlink" title="一个更复杂的例子"></a>一个更复杂的例子</h3><p>&emsp;&emsp; 我们的<code>SingleHost</code>并不重要，我们只检测一个属性，要么将他传递给其他的handler，要么直接返回。然而存在这种情况，我们的程序需要对处理完进行后续处理。</p>
<h3 id="添加数据是简单的"><a href="#添加数据是简单的" class="headerlink" title="添加数据是简单的"></a>添加数据是简单的</h3><p>&emsp;&emsp; 如果只是想简单的添加数据，那么使用Write就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">type AppendMiddleware struct &#123;</div><div class="line">    handler http.Handler</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (a *AppendMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</div><div class="line">    a.handler.ServeHTTP(w, r)</div><div class="line">    w.Write([]byte(&quot;Middleware says hello.&quot;))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; 返回的结构肯定会包含<code>Middleware says hello.</code></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>&emsp;&emsp; 但是操作其他的数据有点困难。例如我们想要在它前面添加数据而不是后面追加。如果我们在原Handler之前调用Write，那么将会失去控制，因为第一个Write已经将他写入了。<br>&emsp;&emsp; 通过其他方法修改原始输出，例如替换字符串，改变响应header，或者设置状态码都不会起作用，因为当handler返回的时候数据已经返回到客户端了。<br>&emsp;&emsp; 为了实现这个功能，我们需要一个特殊的ResponseWriter，他可以想buffer一样工作，收集数据，存储以备使用和修改。然后我们将这个ResponseWriter传递给handler，而不是传递真是的RW，这样在其之前我们已经修改了它了。<br>&emsp;&emsp; 幸运的是在标准库中有这样的一个工具。在<code>net/http/httptest</code>包里的ResponseRecorder能做所有我们需要的：保存状态码，一个响应header的map，将body放入byte 缓冲中。虽然它是再测试中中使用的，但是很服务我们的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">type ModifierMiddleware struct &#123;</div><div class="line">    handler http.Handler</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (m *ModifierMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</div><div class="line">    rec := httptest.NewRecorder()</div><div class="line">    // passing a ResponseRecorder instead of the original RW</div><div class="line">    m.handler.ServeHTTP(rec, r)</div><div class="line">    // after this finishes, we have the response recorded</div><div class="line">    // and can modify it before copying it to the original RW</div><div class="line"></div><div class="line">    // we copy the original headers first</div><div class="line">    for k, v := range rec.Header() &#123;</div><div class="line">        w.Header()[k] = v</div><div class="line">    &#125;</div><div class="line">    // and set an additional one</div><div class="line">    w.Header().Set(&quot;X-We-Modified-This&quot;, &quot;Yup&quot;)</div><div class="line">    // only then the status code, as this call writes out the headers </div><div class="line">    w.WriteHeader(418)</div><div class="line"></div><div class="line">    // The body hasn&apos;t been written (to the real RW) yet,</div><div class="line">    // so we can prepend some data.</div><div class="line">    data := []byte(&quot;Middleware says hello again. &quot;)</div><div class="line"></div><div class="line">    // But the Content-Length might have been set already,</div><div class="line">    // we should modify it by adding the length</div><div class="line">    // of our own data.</div><div class="line">    // Ignoring the error is fine here:</div><div class="line">    // if Content-Length is empty or otherwise invalid,</div><div class="line">    // Atoi() will return zero,</div><div class="line">    // which is just what we&apos;d want in that case.</div><div class="line">    clen, _ := strconv.Atoi(r.Header.Get(&quot;Content-Length&quot;))</div><div class="line">    clen += len(data)</div><div class="line">    r.Header.Set(&quot;Content-Length&quot;, strconv.Itoa(clen))</div><div class="line"></div><div class="line">    // finally, write out our data</div><div class="line">    w.Write(data)</div><div class="line">    // then write out the original body</div><div class="line">    w.Write(rec.Body.Bytes())</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;最后僵尸我们中间件的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 418 I&apos;m a teapot</div><div class="line">X-We-Modified-This: Yup</div><div class="line">Content-Type: text/plain; charset=utf-8</div><div class="line">Content-Length: 37</div><div class="line">Date: Tue, 03 Sep 2013 18:41:39 GMT</div><div class="line"></div><div class="line">Middleware says hello again. Success!</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;这样就开启了一种新的可能，包装的handler完全手控制。</p>
<h3 id="和其他handler分享数据"><a href="#和其他handler分享数据" class="headerlink" title="和其他handler分享数据"></a>和其他handler分享数据</h3><p>&emsp;&emsp; 在其他例子中，中间件可能需要暴露一些信息给其他中间件或者应用本身。例如nosurf需要给其他用户访问CSRF token的权限。<br>&emsp;&emsp; 最简单是是使用一个map，但是通常不希望这样。它将http.Request 的指针作为key，其他数据作为value。下面是nosurf的例子，Go的map非线程安全，所以要自己是实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">type csrfContext struct &#123;</div><div class="line">    token string</div><div class="line">    reason error</div><div class="line">&#125;</div><div class="line"></div><div class="line">var (</div><div class="line">    contextMap = make(map[*http.Request]*csrfContext)</div><div class="line">    cmMutex    = new(sync.RWMutex)</div><div class="line">)</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; 数据由Token设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">func Token(req *http.Request) string &#123;</div><div class="line">    cmMutex.RLock()</div><div class="line">    defer cmMutex.RUnlock()</div><div class="line"></div><div class="line">    ctx, ok := contextMap[req]</div><div class="line">    if !ok &#123;</div><div class="line">            return &quot;&quot;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return ctx.token</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;源码可以再nosurf的项目的<a href="https://github.com/justinas/nosurf/blob/master/context.go" target="_blank" rel="external">context.go</a>中找到。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mashuai.github.io/2015/11/12/使用Go开发HTTP中间件/" data-id="cj0ge8y31000aq0ituk66j0m4" class="article-share-link">Share</a>
      
        <a href="https://mashuai.github.io/2015/11/12/使用Go开发HTTP中间件/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go/">Go</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/">HTTP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Middleware/">Middleware</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-HTTP-2-和GO" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/12/HTTP-2-和GO/" class="article-date">
  <time datetime="2015-11-12T03:39:21.000Z" itemprop="datePublished">2015-11-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/12/HTTP-2-和GO/">HTTP/2 和GO</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://www.ianlewis.org/en/http2-and-go" target="_blank" rel="external">原文地址</a><br>&emsp;&emsp; HTTP/2是一个添加了一些新功能的HTTP的新版本，这些功能包括连接复用，首部压缩。再Go的标准库中暂时还没有HTTP/2的实现，但是现在有很多正在开发的库可以用来在Go中实现HTTP/2的server和client。<br>&emsp;&emsp; Brad Fitzpatrick实现了一个<a href="https://godoc.org/golang.org/x/net/http2" target="_blank" rel="external">golang.org/x/net/http2</a>的库，这个库甚至最终会加入到标准库中，不过他现在正在开发，所以在其他的库中。因为他现在的开发很活跃，所有情况因人而异，但是如果你想实现HTTP/2的服务器，仍然可以使用这个库。</p>
<h3 id="创建HTTP-2服务器"><a href="#创建HTTP-2服务器" class="headerlink" title="创建HTTP/2服务器"></a>创建HTTP/2服务器</h3><p>&emsp;&emsp; 使用http2的库写一个服务器是很简单的。http2库和标准库的http包集成在一起，需要调用<code>http2.ConfigureServer()</code>来配置一个普通http使用HTTP/2协议。如果需要通过浏览器访问或者降级到HTTP 1.x 协议，那么你需要设置TLS 加密。虽然加密不是必须的，但是现在还没有浏览器支持非加密的HTTP/2协议。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">    &quot;log&quot;</div><div class="line">    &quot;net/http&quot;</div><div class="line">    &quot;os&quot;</div><div class="line"></div><div class="line">    &quot;golang.org/x/net/http2&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    cwd, err := os.Getwd()</div><div class="line">    if err != nil &#123;</div><div class="line">        log.Fatal(err)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    srv := &amp;http.Server&#123;</div><div class="line">        Addr:    &quot;:8000&quot;, // Normally &quot;:443&quot;</div><div class="line">        Handler: http.FileServer(http.Dir(cwd)),</div><div class="line">    &#125;</div><div class="line">    http2.ConfigureServer(srv, &amp;http2.Server&#123;&#125;)</div><div class="line">    log.Fatal(srv.ListenAndServeTLS(&quot;server.crt&quot;, &quot;server.key&quot;))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="创建HTTP-2-客户端"><a href="#创建HTTP-2-客户端" class="headerlink" title="创建HTTP/2 客户端"></a>创建HTTP/2 客户端</h3><p>&emsp;&emsp; 现在使用http2的库创建客户端很hacky。虽然它会输出很多调试日志，但是对于大多数情况下运行的很好。可以使用<code>http2.Transport</code>对象，将他传给<code>http</code>包的client。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">    &quot;fmt&quot;</div><div class="line">    &quot;io/ioutil&quot;</div><div class="line">    &quot;log&quot;</div><div class="line">    &quot;net/http&quot;</div><div class="line"></div><div class="line">    &quot;golang.org/x/net/http2&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    client := http.Client&#123;</div><div class="line">        // InsecureTLSDial is temporary and will likely be</div><div class="line">        // replaced by a different API later.</div><div class="line">        Transport: &amp;http2.Transport&#123;InsecureTLSDial: true&#125;,</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    resp, err := client.Get(&quot;https://localhost:8000/&quot;)</div><div class="line">    if err != nil &#123;</div><div class="line">        log.Fatal(err)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    body, err := ioutil.ReadAll(resp.Body)</div><div class="line">    if err != nil &#123;</div><div class="line">        log.Fatal(err)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    fmt.Println(string(body))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h3><p>&emsp;&emsp; 如果你对HTTP/2协议感兴趣，那么可以参考<a href="https://http2.github.io/" target="_blank" rel="external">HTTP/2 主页</a>，这个页面有很多其他资料的连接还有其他语言的实现。<br>&emsp;&emsp; 如果你想知道HTTP/2的服务端和客户端是如何实现的，那么<a href="https://github.com/Jxck/http2" target="_blank" rel="external">Jxck’s http2 implementation</a>的实现就很值得一读。Jxck通过对标准的HTTP库的TLSNextProto设置一个钩子来实现的。你可以再这里阅读一些<a href="https://github.com/Jxck/http2/blob/master/sample/http.go" target="_blank" rel="external">示例</a>。<br>&emsp;&emsp; grpc-go 库同样也有自己的服务端和客户端的实现。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mashuai.github.io/2015/11/12/HTTP-2-和GO/" data-id="cj0ge8y2h0003q0ityul0q6ew" class="article-share-link">Share</a>
      
        <a href="https://mashuai.github.io/2015/11/12/HTTP-2-和GO/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go/">Go</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP-2/">HTTP/2</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Translate/">Translate</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Go-Web-架构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/10/Go-Web-架构/" class="article-date">
  <time datetime="2015-11-10T11:01:21.000Z" itemprop="datePublished">2015-11-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/10/Go-Web-架构/">Go Web 架构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://larry-price.com/blog/2015/06/25/architecture-for-a-golang-web-app" target="_blank" rel="external">原文地址</a></p>
<p>&emsp;&emsp; 使用Golang来创建Web项目是一件很麻烦的事情。如果你使用Rails，那么你可能不会有这个感触。我在<a href="https://www.refer-madness.com/" target="_blank" rel="external">Refer Madness</a>中使用了下面这个架构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-public/</div><div class="line">-views/</div><div class="line">-models/</div><div class="line">-utils/</div><div class="line">-controllers/</div><div class="line">-web/</div><div class="line">-main.go</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; 我将打破这个体系，介绍各个目录的作用。在每个目录下，文件只能访问其同级或者上一级。这就意味着<code>utils</code>只能访问他自己和<code>models</code>，<code>web</code>只能访问它自己，<code>controllers</code>，<code>utils</code>，<code>models</code>。<code>models</code>只能访问它自己。我这么做是为了让层次清晰，防止出现递归依赖。现在来分析每一个目录，文件的作用。</p>
<h4 id="main-go"><a href="#main-go" class="headerlink" title="main.go"></a>main.go</h4><p>&emsp;&emsp; <code>main.go</code>是创建依赖，获取环境变量，启动服务的主要文件。下面是它的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">  &quot;github.com/larryprice/refermadness/utils&quot;</div><div class="line">  &quot;github.com/larryprice/refermadness/web&quot;</div><div class="line">  &quot;github.com/stretchr/graceful&quot;</div><div class="line">  &quot;os&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">  isDevelopment := os.Getenv(&quot;ENVIRONMENT&quot;) == &quot;development&quot;</div><div class="line">  dbURL := os.Getenv(&quot;MONGOLAB_URI&quot;)</div><div class="line">  if isDevelopment &#123;</div><div class="line">    dbURL = os.Getenv(&quot;DB_PORT_27017_TCP_ADDR&quot;)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  dbAccessor := utils.NewDatabaseAccessor(dbURL, os.Getenv(&quot;DATABASE_NAME&quot;), 0)</div><div class="line">  cuAccessor := utils.NewCurrentUserAccessor(1)</div><div class="line">  s := web.NewServer(*dbAccessor, *cuAccessor, os.Getenv(&quot;GOOGLE_OAUTH2_CLIENT_ID&quot;),</div><div class="line">    os.Getenv(&quot;GOOGLE_OAUTH2_CLIENT_SECRET&quot;), os.Getenv(&quot;SESSION_SECRET&quot;),</div><div class="line">    isDevelopment, os.Getenv(&quot;GOOGLE_ANALYTICS_KEY&quot;))</div><div class="line"></div><div class="line">  port := os.Getenv(&quot;PORT&quot;)</div><div class="line">  if port == &quot;&quot; &#123;</div><div class="line">    port = &quot;3000&quot;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  graceful.Run(&quot;:&quot;+port, 0, s)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; 因为<code>main.go</code>实在最低的层级，所以它可以访问所有的目录：在这个例子里是<code>web</code>和<code>utils</code>。在这里获取了所有的环境变量并把它们注入到合适的地方。在<code>main.go</code>中创建了服务器，注入依赖，并且在配置的端口启动服务器。</p>
<h4 id="web"><a href="#web" class="headerlink" title="web"></a>web</h4><p>&emsp;&emsp; <code>web</code>目录下是主要的服务代码，同时也包括了中间件代码。下面是<code>web</code>目录的内部结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-web/</div><div class="line">|-middleware/</div><div class="line">|-server.go</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; <code>server.go</code>包含了web server的定义。这个web server 创建了所有的web controller并且给negroni添加了中间件。下面是他的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">package web</div><div class="line"></div><div class="line">import (</div><div class="line">  &quot;github.com/codegangsta/negroni&quot;</div><div class="line">  &quot;github.com/goincremental/negroni-sessions&quot;</div><div class="line">  &quot;github.com/goincremental/negroni-sessions/cookiestore&quot;</div><div class="line">  &quot;github.com/gorilla/mux&quot;</div><div class="line">  &quot;github.com/larryprice/refermadness/controllers&quot;</div><div class="line">  &quot;github.com/larryprice/refermadness/utils&quot;</div><div class="line">  &quot;github.com/larryprice/refermadness/web/middleware&quot;</div><div class="line">  &quot;github.com/unrolled/secure&quot;</div><div class="line">  &quot;gopkg.in/unrolled/render.v1&quot;</div><div class="line">  &quot;html/template&quot;</div><div class="line">  &quot;net/http&quot;</div><div class="line">)</div><div class="line"></div><div class="line">type Server struct &#123;</div><div class="line">  *negroni.Negroni</div><div class="line">&#125;</div><div class="line"></div><div class="line">func NewServer(dba utils.DatabaseAccessor, cua utils.CurrentUserAccessor, clientID, clientSecret,</div><div class="line">  sessionSecret string, isDevelopment bool, gaKey string) *Server &#123;</div><div class="line">  s := Server&#123;negroni.Classic()&#125;</div><div class="line">  session := utils.NewSessionManager()</div><div class="line">  basePage := utils.NewBasePageCreator(cua, gaKey)</div><div class="line">  renderer := render.New()</div><div class="line"></div><div class="line">  router := mux.NewRouter()</div><div class="line"></div><div class="line">  // ...</div><div class="line"></div><div class="line">  accountController := controllers.NewAccountController(clientID, clientSecret, isDevelopment, session, dba, cua, basePage, renderer)</div><div class="line">  accountController.Register(router)</div><div class="line"></div><div class="line">  // ...</div><div class="line"></div><div class="line">  s.Use(sessions.Sessions(&quot;refermadness&quot;, cookiestore.New([]byte(sessionSecret))))</div><div class="line">  s.Use(middleware.NewAuthenticator(dba, session, cua).Middleware())</div><div class="line">  s.UseHandler(router)</div><div class="line">  return &amp;s</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; <code>Server</code>结构体是一个<code>negroni.Negroni</code>的web server，在这个文件里有对<code>utils</code>和其他第三方包的引用，创建了一个router，一些controller，并且将controller注册到当前router。同时也引入了必要的中间件。说到中间件，下面是它的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">package middleware</div><div class="line"></div><div class="line">import (</div><div class="line">  &quot;github.com/codegangsta/negroni&quot;</div><div class="line">  &quot;github.com/larryprice/refermadness/utils&quot;</div><div class="line">  &quot;net/http&quot;</div><div class="line">)</div><div class="line"></div><div class="line">type Database struct &#123;</div><div class="line">  da utils.DatabaseAccessor</div><div class="line">&#125;</div><div class="line"></div><div class="line">func NewDatabase(da utils.DatabaseAccessor) *Database &#123;</div><div class="line">  return &amp;Database&#123;da&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (d *Database) Middleware() negroni.HandlerFunc &#123;</div><div class="line">  return func(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) &#123;</div><div class="line">    reqSession := d.da.Clone()</div><div class="line">    defer reqSession.Close()</div><div class="line">    d.da.Set(r, reqSession)</div><div class="line">    next(rw, r)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; 这个是通过HTTP router访问数据库session的标注中间件。基本文件是从<a href="http://modocache.svbtle.com/restful-go" target="_blank" rel="external">Brian Gesiak’s blog post on RESTful Go</a>中得到，将其修改为适合我的文件。</p>
<h4 id="controllers"><a href="#controllers" class="headerlink" title="controllers/"></a>controllers/</h4><p>&emsp;&emsp; 这里的controller与Rails里的controller的概念很像。Controller注册自己的router，设置自己的函数调用。一个简短的例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">package controllers</div><div class="line"></div><div class="line">import (</div><div class="line">  &quot;encoding/json&quot;</div><div class="line">  &quot;errors&quot;</div><div class="line">  &quot;github.com/gorilla/mux&quot;</div><div class="line">  &quot;github.com/larryprice/refermadness/models&quot;</div><div class="line">  &quot;github.com/larryprice/refermadness/utils&quot;</div><div class="line">  &quot;gopkg.in/mgo.v2/bson&quot;</div><div class="line">  &quot;gopkg.in/unrolled/render.v1&quot;</div><div class="line">  &quot;html/template&quot;</div><div class="line">  &quot;net/http&quot;</div><div class="line">  &quot;strings&quot;</div><div class="line">)</div><div class="line"></div><div class="line">type ServiceControllerImpl struct &#123;</div><div class="line">  currentUser utils.CurrentUserAccessor</div><div class="line">  basePage    utils.BasePageCreator</div><div class="line">  renderer    *render.Render</div><div class="line">  database    utils.DatabaseAccessor</div><div class="line">&#125;</div><div class="line"></div><div class="line">func NewServiceController(currentUser utils.CurrentUserAccessor, basePage utils.BasePageCreator,</div><div class="line">  renderer *render.Render, database utils.DatabaseAccessor) *ServiceControllerImpl &#123;</div><div class="line">  return &amp;ServiceControllerImpl&#123;</div><div class="line">    currentUser: currentUser,</div><div class="line">    basePage:    basePage,</div><div class="line">    renderer:    renderer,</div><div class="line">    database:    database,</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (sc *ServiceControllerImpl) Register(router *mux.Router) &#123;</div><div class="line">  router.HandleFunc(&quot;/service/&#123;id&#125;&quot;, sc.single)</div><div class="line">  // ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ...</div><div class="line"></div><div class="line">type serviceResult struct &#123;</div><div class="line">  *models.Service</div><div class="line">  RandomCode *models.ReferralCode</div><div class="line">  UserCode   *models.ReferralCode</div><div class="line">&#125;</div><div class="line"></div><div class="line">type servicePage struct &#123;</div><div class="line">  utils.BasePage</div><div class="line">  ResultString string</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (sc *ServiceControllerImpl) single(w http.ResponseWriter, r *http.Request) &#123;</div><div class="line">  data, err := sc.get(w, r)</div><div class="line"></div><div class="line">  if len(r.Header[&quot;Content-Type&quot;]) == 1 &amp;&amp; strings.Contains(r.Header[&quot;Content-Type&quot;][0], &quot;application/json&quot;) &#123;</div><div class="line">    if err != nil &#123;</div><div class="line">      sc.renderer.JSON(w, http.StatusBadRequest, map[string]string&#123;</div><div class="line">        &quot;error&quot;: err.Error(),</div><div class="line">      &#125;)</div><div class="line">      return</div><div class="line">    &#125;</div><div class="line">    sc.renderer.JSON(w, http.StatusOK, data)</div><div class="line">    return</div><div class="line">  &#125; else if err != nil &#123;</div><div class="line">    http.Error(w, err.Error(), http.StatusBadRequest)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  resultString, _ := json.Marshal(data)</div><div class="line">  t, _ := template.ParseFiles(&quot;views/layout.html&quot;, &quot;views/service.html&quot;)</div><div class="line">  t.Execute(w, servicePage&#123;sc.basePage.Get(r), string(resultString)&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="utils"><a href="#utils" class="headerlink" title="utils/"></a>utils/</h4><p>&emsp;&emsp; 在<code>utils</code>目录下的文件提供了一些底层功能用来支持其他的代码。在这个例子中，主要是定义一个结构体来访问请求的上下文，处理session，定义一个特别的页面来继承。下面是通过访问上下文设置用户的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">package utils</div><div class="line"></div><div class="line">import (</div><div class="line">  &quot;github.com/gorilla/context&quot;</div><div class="line">  &quot;github.com/larryprice/refermadness/models&quot;</div><div class="line">  &quot;net/http&quot;</div><div class="line">)</div><div class="line"></div><div class="line">type CurrentUserAccessor struct &#123;</div><div class="line">  key int</div><div class="line">&#125;</div><div class="line"></div><div class="line">func NewCurrentUserAccessor(key int) *CurrentUserAccessor &#123;</div><div class="line">  return &amp;CurrentUserAccessor&#123;key&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (cua *CurrentUserAccessor) Set(r *http.Request, user *models.User) &#123;</div><div class="line">  context.Set(r, cua.key, user)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (cua *CurrentUserAccessor) Clear(r *http.Request) &#123;</div><div class="line">  context.Delete(r, cua.key)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (cua *CurrentUserAccessor) Get(r *http.Request) *models.User &#123;</div><div class="line">  if rv := context.Get(r, cua.key); rv != nil &#123;</div><div class="line">    return rv.(*models.User)</div><div class="line">  &#125;</div><div class="line">  return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="models"><a href="#models" class="headerlink" title="models/"></a>models/</h4><p>&emsp;&emsp; model 是为了描述数据库中的数据的数据结构。在这个例子中使用model来访问数据库，创建一个空的model，然后通过查询数据库为其赋值。下面是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">package models</div><div class="line"></div><div class="line">import (</div><div class="line">  &quot;gopkg.in/mgo.v2&quot;</div><div class="line">  &quot;gopkg.in/mgo.v2/bson&quot;</div><div class="line">  &quot;strings&quot;</div><div class="line">  &quot;time&quot;</div><div class="line">)</div><div class="line"></div><div class="line">type Service struct &#123;</div><div class="line">  // identification information</div><div class="line">  ID          bson.ObjectId `bson:&quot;_id&quot;`</div><div class="line">  Name        string        `bson:&quot;name&quot;`</div><div class="line">  Description string        `bson:&quot;description&quot;`</div><div class="line">  URL         string        `bson:&quot;url&quot;`</div><div class="line">  Search      string        `bson:&quot;search&quot;`</div><div class="line">&#125;</div><div class="line"></div><div class="line">func NewService(name, description, url string, creatorID bson.ObjectId) *Service &#123;</div><div class="line">  url = strings.TrimPrefix(strings.TrimPrefix(url, &quot;http://&quot;), &quot;https://&quot;)</div><div class="line">  return &amp;Service&#123;</div><div class="line">    ID:            bson.NewObjectId(),</div><div class="line">    Name:          name,</div><div class="line">    URL:           url,</div><div class="line">    Description:   description,</div><div class="line">    Search:        strings.ToLower(name) + &quot;;&quot; + strings.ToLower(description) + &quot;;&quot; + strings.ToLower(url),</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (s *Service) Save(db *mgo.Database) error &#123;</div><div class="line">  _, err := s.coll(db).UpsertId(s.ID, s)</div><div class="line">  return err</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (s *Service) FindByID(id bson.ObjectId, db *mgo.Database) error &#123;</div><div class="line">  return s.coll(db).FindId(id).One(s)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (*Service) coll(db *mgo.Database) *mgo.Collection &#123;</div><div class="line">  return db.C(&quot;service&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">type Services []Service</div><div class="line"></div><div class="line">func (s *Services) FindByIDs(ids []bson.ObjectId, db *mgo.Database) error &#123;</div><div class="line">  return s.coll(db).Find(bson.M&#123;&quot;_id&quot;: bson.M&#123;&quot;$in&quot;: ids&#125;&#125;).Sort(&quot;name&quot;).All(s)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (*Services) coll(db *mgo.Database) *mgo.Collection &#123;</div><div class="line">  return db.C(&quot;service&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="views"><a href="#views" class="headerlink" title="views/"></a>views/</h4><p>&emsp;&emsp; 将Golang的模板文件放到<code>views</code>目录下。这样，不管用什么样的模板引擎都可以直接放到<code>views</code>下。</p>
<h4 id="public"><a href="#public" class="headerlink" title="public/"></a>public/</h4><p>&emsp;&emsp; 跟以前一样，这个文件都是放公开的文件的，例如<code>css</code>,<code>img</code>,<code>scripts</code>。</p>
<h4 id="如何运行"><a href="#如何运行" class="headerlink" title="如何运行"></a>如何运行</h4><p>&emsp;&emsp; 毫无疑问，我最喜欢的就是<a href="https://www.docker.com/" target="_blank" rel="external">docker</a>，因此我将使用他来运行这个应用。如果不使用docker，那么可以将文件放到<code>$GOPATH/src/github.com/larryprice/refermadness</code>,运行<code>go get</code>来获取所有的依赖，然后运行 <code>go run main.go</code>或者<code>go build; ./refermadness</code>运行程序。如果你也喜欢使用docker，那么可以直接通过<code>Dockerfile</code>来运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">FROM golang:1.4</div><div class="line"></div><div class="line">RUN go get github.com/codegangsta/gin</div><div class="line"></div><div class="line">ADD . /go/src/github.com/larryprice/refermadness</div><div class="line">WORKDIR /go/src/github.com/larryprice/refermadness</div><div class="line">RUN go get</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; 同时我也很喜欢<a href="https://github.com/docker/compose" target="_blank" rel="external">compose</a>，所以我也通过compose 文件来运行所有的应用。我用了JSC ，SASS和mongodb，所以一下是我的<code>docker-compose.yml</code>文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">main:</div><div class="line">  build: .</div><div class="line">  command: gin run</div><div class="line">  env_file: .env</div><div class="line">  volumes:</div><div class="line">    - ./:/go/src/github.com/larryprice/refermadness</div><div class="line">  working_dir: /go/src/github.com/larryprice/refermadness</div><div class="line">  ports:</div><div class="line">    - &quot;3000:3000&quot;</div><div class="line">  links:</div><div class="line">    - db</div><div class="line">sass:</div><div class="line">  image: larryprice/sass</div><div class="line">  volumes:</div><div class="line">    - ./public/css:/src</div><div class="line">jsx:</div><div class="line">  image: larryprice/jsx</div><div class="line">  volumes:</div><div class="line">    - ./public/scripts:/src</div><div class="line">db:</div><div class="line">  image: mongo:3.0</div><div class="line">  command: mongod --smallfiles --quiet --logpath=/dev/null</div><div class="line">  volumes_from:</div><div class="line">    - dbvolume</div><div class="line">dbvolume:</div><div class="line">  image: busybox:ubuntu-14.04</div><div class="line">  volumes:</div><div class="line">    - /data/db</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; 然后运行<code>docker-compose up</code>来运行所有的容器并启动服务器。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mashuai.github.io/2015/11/10/Go-Web-架构/" data-id="cj0ge8y270001q0itjwa1xy7c" class="article-share-link">Share</a>
      
        <a href="https://mashuai.github.io/2015/11/10/Go-Web-架构/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Architecture/">Architecture</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go/">Go</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Translate/">Translate</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Ansible-入门指南" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/09/Ansible-入门指南/" class="article-date">
  <time datetime="2015-11-09T10:26:35.000Z" itemprop="datePublished">2015-11-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/09/Ansible-入门指南/">Ansible 入门指南</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://docs.ansible.com/ansible/intro_getting_started.html" target="_blank" rel="external">原文地址</a></p>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp; 现在你已经知道如何<a href="http://docs.ansible.com/ansible/intro_installation.html" target="_blank" rel="external">安装</a>Ansible了，现在可以深入并开始使用Ansible的一些命令了。<br>&emsp;&emsp; 我们开始展示的并不是Ansible强大的配置、部署、调度的功能。这些功能由其他章节要讲的Playbook来处理。<br>&emsp;&emsp; 这个章节是关于如何快速入门的。等你了解了Ansible的这些概念之后，就可以阅读<a href="http://docs.ansible.com/ansible/intro_adhoc.html" target="_blank" rel="external">特别命令简介</a>来学习更多细节，接着你就可以深入理解Playbook，并且浏览更多的有趣功能。</p>
<h3 id="远程连接信息"><a href="#远程连接信息" class="headerlink" title="远程连接信息"></a>远程连接信息</h3><p>&emsp;&emsp; 在我们开始学习之前，理解Ansible是如何通过SSH连接到远程服务器是很重要的。<br>&emsp;&emsp; 默认情况下，如果可以，Ansible 1.3 及其后续版本会使用原生的OpenSSh来连接远程服务器。这样就可以在~/.ssh/config下开启ControPersist(一个高性能的功能),Kerbos和其他选项，例如跳板机设置。然后，如果使用了Enterprise Linux 6(Red Hat Enterprise Linux 和其衍生版本，例如CentOS) 系统作为控制机，OpenSSH的版本可能过低导致无法开启ControlPersist功能。在这些操作系统中，Ansible将会回退到使用“paramiko”，他是OpenSSH的一个高质量的Python实现。如果你想使用像Kerberized SSH 等这样的功能，那么可以使用Federa，OSX或者Ubuntu作为你的控制机，直到你使用的平台有了更新的OpenSSH，或者你可以开启加速功能。<a href="http://docs.ansible.com/ansible/playbooks_acceleration.html" target="_blank" rel="external">加速功能</a>。<br>&emsp;&emsp; 如果使用的版本小于等于1.2，那么默认使用的就是paramiko，如果想要使用原生的SSH，那么需要加上-c ssh 选项或者再配置文件中配置。<br>&emsp;&emsp; 可能偶尔在某些机器上不支持SFTP协议，虽然这种情况很少，但是也可能发生，这个时候可以在<a href="http://docs.ansible.com/ansible/intro_configuration.html" target="_blank" rel="external">配置文件</a>中切换到SCP模式。<br>&emsp;&emsp; 当需要和远程主机会话是，Ansible默认假设你使用SSH keys。Ansible鼓励使用SSH 免密码登陆，但是使用密码登陆也是可以的，在使用的时候加上参数<code>--ask-pass</code>。如果需要使用sudo权限，那么也要提供<code>--ask-sudo-pass</code>参数。<br>&emsp;&emsp; 任何管理系统运行时离被管理的系统越近越好。虽然这是个常识，但是还是值得分享的。如果你在云端使用Ansible，那么就把Ansible运行在云端。在大多数情况下，它都比直接在公共网络上运行更好。<br>&emsp;&emsp; 作为一个高级话题，Ansible并不仅仅通过SSH连接主机。连接系统是可插拔的，有很多配置选项可以用来本地管理，例如管理chroot，lxc，jail container。一个叫做“Ansible-pull”的模式可以反转系统。通过配置好的git checkout 从中央存储库pull配置文件获取系统的“phone home”。</p>
<h3 id="第一个命令"><a href="#第一个命令" class="headerlink" title="第一个命令"></a>第一个命令</h3><p>&emsp;&emsp; 目前为止，已经安装好Ansible了，现在可以开始运行一些简单的命令了。<br>&emsp;&emsp; 编辑（或者创建）<code>/etc/ansible/hosts</code>文件，向其添加一个或者多个远程主机地址。本机的public ssh key 应该已经追加到远程主机的<code>authorized_keys</code>文件中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">192.168.1.50</div><div class="line">aserver.example.org</div><div class="line">bserver.example.org</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; 这是一个清单文件，同样会再<a href="http://docs.ansible.com/ansible/intro_inventory.html" target="_blank" rel="external">主机清单</a>中介绍。<br>&emsp;&emsp; 假设你使用的是SSH授权方式，设置ssh angent 防止重复输入密码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ssh-agent bash</div><div class="line">ssh-add ~/.ssh/id_rsa</div></pre></td></tr></table></figure>
<p>(根据你的设置，你可能需要使用<code>--private-key</code>选项来制定一个pem文件)<br>&emsp;&emsp; 现在可以ping一下所有的主机了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ansible all -m ping</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; Ansible会想SSH那样使用你本机的用户名去连接远程机器，如果不想使用本机用户名，可以加上<code>-u</code>的选项。<br>&emsp;&emsp; 如果你想使用sudo权限，同样也可以将上<code>--sudo</code>选项。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># as bruce</div><div class="line">$ ansible all -m ping -u bruce</div><div class="line"># as bruce sudoing to root</div><div class="line">$ ansible all -m ping -u bruce --sudo</div><div class="line"># as bruce, sudoing to batman</div><div class="line">$ ansible all -m ping -u bruce --sudo --sudo-user batman</div><div class="line"></div><div class="line"># With latest version of ansible `sudo` is deprecated so use become</div><div class="line"># as bruce, sudoing to root</div><div class="line">$ ansible all -m ping -u bruce -b</div><div class="line"># as bruce, sudoing to batman</div><div class="line">$ ansible all -m ping -u bruce -b --become-user batman</div></pre></td></tr></table></figure>
<p>(如果你突然想改变sudo 用户，可以再配置文件中修改。传递给sudo的标记例如-H也可以在那修改。)</p>
<p>&emsp;&emsp; 现在在你所有的节点上运行一个实时的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ansible all -a &quot;/bin/echo hello&quot;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; 太棒了，刚刚通过Ansible与远程主机会话了。很快就可以阅读<a href="http://docs.ansible.com/ansible/intro_adhoc.html" target="_blank" rel="external">更多命令介绍</a>来学习更多的实际例子，浏览各个模块都可以做什么，以及学习Ansible <a href="http://docs.ansible.com/ansible/playbooks.html" target="_blank" rel="external">Playbooks</a>的语法。Ansible不仅仅只能用来运行命令，他还有强大的配置管理系统和部署功能。还有许多需要学习的知识，但是你现在已经有一个完全可以运行的环境了。</p>
<h3 id="主机密钥检查"><a href="#主机密钥检查" class="headerlink" title="主机密钥检查"></a>主机密钥检查</h3><p>&emsp;&emsp; Ansible 1.2.1 及其之后的版本，默认是有主机密钥检查功能的。<br>&emsp;&emsp; 如果远程主机成新安装并且在<code>know_hosts</code>下有一个不同的key，直到修复之前，Ansible会一直返回错误。如果主机没有在<code>know_hosts</code>文件中，那么会出现提示来确认密钥。这样就会有一个你不希望的提示。<br>&emsp;&emps; 如果你知道这个功能的影响，并且希望关闭这个功能，可以修改<code>/etc/ansible/ansible.cfg</code>或者是<code>~/.ansible.cfg</code>来关闭这个功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[default]</div><div class="line">host_key_checking = False</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; 同样也可以通过环境变量来修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ export ANSIBLE_HOST_KEY_CHECKING=False</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; 同时要注意主机密钥检查再paramiko模式中是很慢的，所以如果要使用这个功能最好使用ssh模式。<br>&emsp;&emsp; 除非Ansible的任务被标记为”no_log:True”，否则Ansible会再远程注意的syslog中记录一些有用的信息。这个稍后再做解释。<br>&emsp;&emsp; 如果要再本机开启log可以查看<a href="http://docs.ansible.com/ansible/intro_configuration.html" target="_blank" rel="external">配置章节</a>来设置“log_path”开启。企业用户可能会对<a href="http://docs.ansible.com/ansible/tower.html" target="_blank" rel="external">Ansible Tower</a>。Tower提供了一个健壮的数据库记录日志的功能，这样就可以随时通过图形界面或者REST API 来查看主机，项目，特殊的列表的日志。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mashuai.github.io/2015/11/09/Ansible-入门指南/" data-id="cj0ge8y210000q0itwbnuvri3" class="article-share-link">Share</a>
      
        <a href="https://mashuai.github.io/2015/11/09/Ansible-入门指南/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ansible/">Ansible</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Translate/">Translate</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ansible/">Ansible</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Architecture/">Architecture</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Go/">Go</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/">HTTP</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-2/">HTTP/2</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Middleware/">Middleware</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OKHttp/">OKHttp</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OkHttp/">OkHttp</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Translate/">Translate</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vagrant/">Vagrant</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Ansible/" style="font-size: 12.5px;">Ansible</a> <a href="/tags/Architecture/" style="font-size: 10px;">Architecture</a> <a href="/tags/Go/" style="font-size: 17.5px;">Go</a> <a href="/tags/HTTP/" style="font-size: 17.5px;">HTTP</a> <a href="/tags/HTTP-2/" style="font-size: 10px;">HTTP/2</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Middleware/" style="font-size: 10px;">Middleware</a> <a href="/tags/OKHttp/" style="font-size: 12.5px;">OKHttp</a> <a href="/tags/OkHttp/" style="font-size: 12.5px;">OkHttp</a> <a href="/tags/Translate/" style="font-size: 20px;">Translate</a> <a href="/tags/Vagrant/" style="font-size: 12.5px;">Vagrant</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a><span class="archive-list-count">8</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/03/19/okhttp/interceptors/">OKHttp 拦截器</a>
          </li>
        
          <li>
            <a href="/2017/03/18/okhttp/Recipes/">OKHttp Recipes</a>
          </li>
        
          <li>
            <a href="/2017/03/18/okhttp/connections/">OKHttp connections</a>
          </li>
        
          <li>
            <a href="/2017/03/18/okhttp/calls/">OKHttp的调用</a>
          </li>
        
          <li>
            <a href="/2015/11/14/为Go-Web-App-创建一个主页面/">为Go Web App 创建一个主页面</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 mashuai<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script>
  var disqus_shortname = 'jabfor';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>